//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework// Copyright 2006 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework Extras// File: JSLayoutManager.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Imports////////////////////////////////////////////////////////////////////////////////import mx.events.EventDispatcher;//////////////////////////////////////////////////////////////////////////////////// Class: JSLayoutManager///////////////////////////////////////////////////////////////////////////////////** * JumpShip Layout Manager Class. This class provides basic tools for laying out* an arbitrary number of objects in a given space. At the present time there are* four ways to lay out these objects: tile - objects are layed out in a grid* fashion. helix - objects are layed out in a helix or corkscrew going back in* space. row - objects are layed out to fit in one row equally spaced. column - * objects are layed out to fit in a column equally spaced.*/class com.jsjstudios.jumpship.extras.JSLayoutManager{		//	// On Stage	//				//	// Properties	//	private var _layoutMode:String 	// "tile"	private var _padding:Number 	// 	private var _startingAngle:Number 	// 	private var _angleDelta:Number 	// 	private var _center:Object 	// 	private var _zDelta:Number 	// 	private var _radius:Number			//	// Assets	//	private var myLayoutObjects:Array // an array of all of the Objects registered									  // to this class (in no particular order)									  	private var boundingObject:MovieClip	private var boundingBox:Object			//	// Intervals	//				//	// Constants	//	//	// Functions	//	/**	* This class issues the following events: 	* layoutUpdatedEvent(JSLayoutManager);	*/	public var addListener:Function;		// Used by AsBroadcaster	public var removeListener:Function;		// Used by AsBRoadcaster	public var broadcastMessage:Function;	// Used by AsBroadcaster to broadcast message		/**	* This class issues the following events: 	* layoutUpdatedEvent({type:"layoutUpdatedEvent", target:JSMouseManager});      	*/	public var addEventListener:Function;		// Used by EventDispatcher	public var removeEventListener:Function;	// Used by EventDispatcher	public var dispatchEvent:Function;			// Used by EventDispatcher	public var dispatchQueue:Function;			// Used by EventDispatcher		////////////////////////////////////////////////////////////////////////////////	//	// Constructor	//	////////////////////////////////////////////////////////////////////////////////	function JSLayoutManager ()	{				// Define the array of depth objects		myLayoutObjects = new Array();				// Initialize AsBroadcaster to enable event broadcasting		AsBroadcaster.initialize(this);				// Initialize EventDispatcher to enable event dispatching		EventDispatcher.initialize(this);				_padding = 1;		_layoutMode = "tile";		_startingAngle = 0;		_angleDelta = 30;		_center = {x:0,y:0}		_zDelta = 50		_radius = 150;				boundingObject = _root;				boundingBox = {x1:0, y1:0, x2:Stage.width, y2:Stage.height}					}		////////////////////////////////////////////////////////////////////////////////	//	// Public Methods	//	////////////////////////////////////////////////////////////////////////////////		// Method for registering an Object to this class	public function registerLayoutObject(theObject:Object, thePosition:Object, thePositionType:String, thePadding:Object):Void {				// Save the object to the array		myLayoutObjects.push({object:theObject, position:thePosition, positionType:thePositionType, padding:thePadding});			}		// Method for unregistering the object	public function unregisterLayoutObject(theObject:Object):Void {				// go through all of the registered objects to find this one		for (var i = 0; i < myLayoutObjects.length; i++) {						// remove this object from the array			if (theObject == myLayoutObjects[i].object) {								myLayoutObjects.splice(i,1);							}					}			}		public function updateLayout():Void {				if (_layoutMode == "tile") {					updateTile();					} else if (_layoutMode == "helix") {						updateHelix();					} else if (_layoutMode == "row") {						updateSingleRow();					} else if (_layoutMode == "column") {						updateSingleColumn();					}			}		public function updateObject(theObject:Object, thePosition:Object, thePositionType:String, thePadding:Object):Void {			// go through all of the registered objects to find this one		for (var i = 0; i < myLayoutObjects.length; i++) {						// remove this object from the array			if (theObject == myLayoutObjects[i].object) {								myLayoutObjects.splice(i,1, {object:theObject, position:thePosition, positionType:thePositionType, padding:thePadding});							}					}				updateLayout();			}		public function setBoundingObject(theObject:MovieClip) {				boundingObject = theObject;		boundingBox = {x1:boundingObject._x, y1:boundingObject._y, x2:(boundingObject._x+boundingObject._width), y2:(boundingObject._y+boundingObject._height)}			}		public function setBoundingBox(theObject:Object) {		boundingBox = {x1:theObject.x1, y1:theObject.y1, x2:theObject.x2, y2:theObject.y2}			}		////////////////////////////////////////////////////////////////////////////////	//	// Private Functions	//	////////////////////////////////////////////////////////////////////////////////		private function updateTile():Void {				var myRow:Number = 0;		var myPos:Number = 0;				var myVertMarker:Number = 0;		var myHorizMarker:Number = 0;		var tempMaxHeight:Number = 0;		var myAbsoluteObjects:Array = new Array();				for (var i = 0; i < myLayoutObjects.length; i++) {						if (myLayoutObjects[i].positionType == "absolute") {								myAbsoluteObjects.push(myLayoutObjects[i].object);							}					}				for (var i = 0; i < myLayoutObjects.length; i++) {						// Update Padding variables			if (myLayoutObjects[i].padding == undefined) {								var lPadding = _padding;				var rPadding = _padding;				var tPadding = _padding;				var bPadding = _padding;							} else {								var lPadding = myLayoutObjects[i].padding.left;				var rPadding = myLayoutObjects[i].padding.right;				var tPadding = myLayoutObjects[i].padding.top;				var bPadding = myLayoutObjects[i].padding.bottom;							}						var tempFlag:Boolean = false;						for (var j = 0; j < myAbsoluteObjects.length; j++) {								if (myAbsoluteObjects[j] == myLayoutObjects[i].object) {										tempFlag = true;									}							}						// If this object doesn't have 'absolute' positioning			if (!tempFlag) {							// Horizontal Layout				//if ((myHorizMarker + myLayoutObjects[i].object._width + lPadding) < (Stage.width)) {				if ((myHorizMarker + myLayoutObjects[i].object._width + lPadding) < (boundingBox.x1 + boundingBox.x2)) {										myHorizMarker += lPadding;										myPos++;								// Next row				} else {					myVertMarker += (tempMaxHeight+tPadding);					tempMaxHeight = 0;					myPos = 0;					myRow++;					myHorizMarker = lPadding;									}								// Pre - position				myLayoutObjects[i].object._x = boundingBox.x1 + myHorizMarker;				myLayoutObjects[i].object._y = boundingBox.y1 + myVertMarker;								//myLayoutObjects[i].object._x = myHorizMarker;				//myLayoutObjects[i].object._y = myVertMarker;								// Check for collisions with "absolute" placed objects				var tempObj:Object = undefined;							for (var j = 0; j < myAbsoluteObjects.length; j++) {										if (myLayoutObjects[i].object.hitTest(myAbsoluteObjects[j])) {												tempObj = myAbsoluteObjects[j];						break;											}									}								// There was a collision				if (tempObj != undefined) {										// Horizontal Layout					//if ((myLayoutObjects[i].object._width + tempObj._x + tempObj._width + lPadding) < (Stage.width)) {					if ((myLayoutObjects[i].object._width + tempObj._x + tempObj._width + lPadding) < (boundingBox.x1 + boundingBox.x2)) {												myLayoutObjects[i].object._x = boundingBox.x1 + tempObj._x + tempObj._width + lPadding;						myLayoutObjects[i].object._y = boundingBox.y1 + myVertMarker;												//myLayoutObjects[i].object._x = tempObj._x + tempObj._width + lPadding;						//myLayoutObjects[i].object._y = myVertMarker;										// Next row					} else {												myVertMarker += (tempMaxHeight+tPadding);						tempMaxHeight = 0;						myPos = 0;						myRow++;						myHorizMarker = lPadding;												myLayoutObjects[i].object._x = boundingBox.x1 + myHorizMarker;						myLayoutObjects[i].object._y = boundingBox.y1 + myVertMarker;												//myLayoutObjects[i].object._x = myHorizMarker;						//myLayoutObjects[i].object._y = myVertMarker;											}					// Position															// Update Horizontal offset					myHorizMarker = myLayoutObjects[i].object._x + myLayoutObjects[i].object._width + rPadding;									} else {									// Position					// Retain the Pre-Position										// Update Horizontal offset					myHorizMarker += myLayoutObjects[i].object._width + rPadding;									}																	// Update Vertical offset								if ((myLayoutObjects[i].object._height+bPadding) > tempMaxHeight) {												tempMaxHeight = myLayoutObjects[i].object._height+bPadding;											}							// this objects position is 'absolute'			} else {								myLayoutObjects[i].object._x = myLayoutObjects[i].object.position.horizontal;				myLayoutObjects[i].object._y = myLayoutObjects[i].object.position.vertical;							}					}			}		private function updateHelix():Void {				var myRow:Number = 0;		var myPos:Number = 0;				var myVertMarker:Number = 0;		var myHorizMarker:Number = 0;		var tempMaxHeight:Number = 0;		var myAbsoluteObjects:Array = new Array();				for (var i = 0; i < myLayoutObjects.length; i++) {						if (myLayoutObjects[i].positionType == "absolute") {								myAbsoluteObjects.push(myLayoutObjects[i].object);							}					}				for (var i = 0; i < myLayoutObjects.length; i++) {						var tempFlag:Boolean = false;			var tempAngle:Number = (_startingAngle+i*_angleDelta)*(Math.PI/180);						myLayoutObjects[i].object.swapDepths(myLayoutObjects.length - i);						for (var j = 0; j < myAbsoluteObjects.length; j++) {								if (myAbsoluteObjects[j] == myLayoutObjects[i].object) {										tempFlag = true;									}							}						// If this object doesn't have 'absolute' positioning			if (!tempFlag) {								myLayoutObjects[i].object._x = _center.x+_radius*Math.cos(tempAngle);				myLayoutObjects[i].object._y = _center.y+_radius*Math.sin(tempAngle);				myLayoutObjects[i].object.x = myLayoutObjects[i].object._x;				myLayoutObjects[i].object.y = myLayoutObjects[i].object._y;				myLayoutObjects[i].object.z = i*_zDelta;								project(myLayoutObjects[i].object);							// this objects position is 'absolute'			} else {								myLayoutObjects[i].object._x = myLayoutObjects[i].object.position.horizontal;				myLayoutObjects[i].object._y = myLayoutObjects[i].object.position.vertical;							}					}			}		private function updateSingleRow():Void {				var myAbsoluteObjects:Array = new Array();				for (var i = 0; i < myLayoutObjects.length; i++) {						if (myLayoutObjects[i].positionType == "absolute") {								myAbsoluteObjects.push(myLayoutObjects[i].object);							}					}				var tempFlag:Boolean = true;		var tempCounter:Number = myLayoutObjects.length-1;				while (tempFlag) {						tempFlag = false;						for (var j = 0; j < myAbsoluteObjects.length; j++) {								if (myAbsoluteObjects[j] == myLayoutObjects[tempCounter].object) {										tempFlag = true;					tempCounter--;									}							}					}				var myRealWidth:Number = (boundingBox.x2 - boundingBox.x1 - myLayoutObjects[tempCounter].object._width);					var myDelta:Number = myRealWidth/myLayoutObjects.length;				for (var i = 0; i < myLayoutObjects.length; i++) {						var tempFlag:Boolean = false;						for (var j = 0; j < myAbsoluteObjects.length; j++) {								if (myAbsoluteObjects[j] == myLayoutObjects[i].object) {										tempFlag = true;									}							}						// If this object doesn't have 'absolute' positioning			if (!tempFlag) {								myLayoutObjects[i].object._x = boundingBox.x1 + i*myDelta;				myLayoutObjects[i].object._y = boundingBox.y1;									// this objects position is 'absolute'			} else {								myLayoutObjects[i].object._x = myLayoutObjects[i].object.position.horizontal;				myLayoutObjects[i].object._y = myLayoutObjects[i].object.position.vertical;							}					}			}		private function updateSingleColumn():Void {				var myAbsoluteObjects:Array = new Array();				for (var i = 0; i < myLayoutObjects.length; i++) {						if (myLayoutObjects[i].positionType == "absolute") {								myAbsoluteObjects.push(myLayoutObjects[i].object);							}					}				var tempFlag:Boolean = true;		var tempCounter:Number = myLayoutObjects.length-1;				while (tempFlag) {						tempFlag = false;						for (var j = 0; j < myAbsoluteObjects.length; j++) {								if (myAbsoluteObjects[j] == myLayoutObjects[tempCounter].object) {										tempFlag = true;					tempCounter--;									}							}					}				var myRealHeight:Number = (boundingBox.y2 - boundingBox.y1 - myLayoutObjects[tempCounter].object._height);					var myDelta:Number = myRealHeight/myLayoutObjects.length;				for (var i = 0; i < myLayoutObjects.length; i++) {						var tempFlag:Boolean = false;						for (var j = 0; j < myAbsoluteObjects.length; j++) {								if (myAbsoluteObjects[j] == myLayoutObjects[i].object) {										tempFlag = true;									}							}						// If this object doesn't have 'absolute' positioning			if (!tempFlag) {								myLayoutObjects[i].object._y = boundingBox.y1 + i*myDelta;									// this objects position is 'absolute'			} else {								myLayoutObjects[i].object._x = myLayoutObjects[i].object.position.horizontal;				myLayoutObjects[i].object._y = myLayoutObjects[i].object.position.vertical;							}					}			}		private function degToRad(theAngle):Number {				return theAngle*Math.PI/180;			}		private function project(theObject) {				var pers = 200/(theObject.z+200);		theObject._x = pers*theObject.x;		theObject._y = pers*theObject.y;		theObject._xscale = theObject._yscale = pers*100;			}		////////////////////////////////////////////////////////////////////////////////	//	// Event Handlers	//	////////////////////////////////////////////////////////////////////////////////		private function updateLayoutEvent():Void {				if (_layoutMode == "tile") {					updateTile();					} else if (_layoutMode == "helix") {						updateHelix();					}				this.broadcastMessage("layoutUpdatedEvent", this);		this.dispatchEvent({type:"layoutUpdatedEvent", target:this});			}		////////////////////////////////////////////////////////////////////////////////	//	// Getters/Setters	//	////////////////////////////////////////////////////////////////////////////////		public function get layoutMode():String {				return _layoutMode;			}	public function set layoutMode(theMode:String):Void {				_layoutMode = theMode;			}		public function get padding():Number {				return _padding;			}	public function set padding(thePadding:Number):Void {				_padding = thePadding;			}		public function get startingAngle():Number {				return _startingAngle;			}	public function set startingAngle(theAngle:Number):Void {				_startingAngle = theAngle;			}		public function get angleDelta():Number {				return _angleDelta;			}	public function set angleDelta(theAngle:Number):Void {				_angleDelta = theAngle;			}		public function get center():Object {				return _center;			}	public function set center(theCenter:Object):Void {				_center = theCenter;			}		public function get radius():Number {				return _radius;			}	public function set radius(theNumber:Number):Void {				_radius = theNumber;			}		public function get zDelta():Number {				return _zDelta;			}	public function set zDelta(theNumber:Number):Void {				_zDelta = theNumber;			}		}  // Class End