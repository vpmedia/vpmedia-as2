//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework// Copyright 2006 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework Extras// File: JSDragDropManager.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Imports////////////////////////////////////////////////////////////////////////////////import com.jsjstudios.jumpship.extras.JSDepthManager;import com.jsjstudios.jumpship.extras.JSMouseManager;import mx.events.EventDispatcher;//////////////////////////////////////////////////////////////////////////////////// Class: JSDragDropManager///////////////////////////////////////////////////////////////////////////////////*** JumpShip Drag / Drop Manager Class. This Class manages basic drag / drop* behavior. It can also determine if the item being dragged was dropped on* a registered target object. It also provides the ability for the item being* dragged to be cloned so that a the original will stay put. Finally it* provides the ability to proxy one object to act as a "hotspot" to drag* another.*/class com.jsjstudios.jumpship.extras.JSDragDropManager {		//	// On Stage	//				//	// Properties	//	private var _currentState:String;	private var _currentDragObject:MovieClip;	private var _makeCopy:Boolean;	private var _workingDepth:Number;		//	// Assets	//	private var myDragObjects:Array	private var targetList:Array;	private var myDepthManager:JSDepthManager;	private var initialPosition:Object	private var tempDragObject:MovieClip;			//	// Intervals	//				//	// Constants	//	private var DEFAULTDEPTH:Number = 1000;		//	// Functions	//	/**	* This class issues the following events: 	* startDragEvent(theObject);	* dropEvent( theObject, theTarget, {x:initial_x_Position, y:initial_y_Position});	* invalidDropEvent(theObject); 	* dropTopmostEvent(theObject, theTarget, {x:initial_x_Position, y:initial_y_Position});	* stopDragEvent(theObject);	* hoverEvent(theObject, theTarget);	* hoverTopmostEvent(theObject, theTarget);	* updateDragEvent( theCurrentDragObject );	*/	public var addListener:Function;		// Used by AsBroadcaster	public var removeListener:Function;		// Used by AsBRoadcaster	public var broadcastMessage:Function;	// Used by AsBroadcaster to broadcast message		/**	* This class issues the following events: 	* dispatchEvent({type:"startDragEvent", target:JSDragDropManager, params:theObject});	* dispatchEvent( {type:"dropEvent", target:JSDragDropManager, params:{ object:theObject, target:theTarget, position:{x:initial_x_Position, y:initial_y_Position}}});	* dispatchEvent({type:"invalidDropEvent", target:JSDragDropManager, params:theObject}); 	* dispatchEvent({type:"dropTopmostEvent", target:JSDragDropManager, params:{ object:theObject, target:theTarget, position:{x:initial_x_Position, y:initial_y_Position}}});	* dispatchEvent({type:"stopDragEvent", target:JSDragDropManager, params:theObject});	* dispatchEvent({type:"hoverEvent", target:JSDragDropManager, params:{ object:theObject, target:theTarget}});	* dispatchEvent({type:"hoverTopmostEvent", target:JSDragDropManager, params:{ object:theObject, target:theTarget}});	* dispatchEvent({type:"updateDragEvent", target:JSDragDropManager, params:theCurrentDragObject );	*/	public var addEventListener:Function;		// Used by EventDispatcher	public var removeEventListener:Function;	// Used by EventDispatcher	public var dispatchEvent:Function;			// Used by EventDispatcher	public var dispatchQueue:Function;			// Used by EventDispatcher		////////////////////////////////////////////////////////////////////////////////	//	// Constructor	//	////////////////////////////////////////////////////////////////////////////////	function JSDragDropManager ()	{				// Initialize AsBroadcaster to enable event broadcasting		AsBroadcaster.initialize(this);				// Initialize EventDispatcher to enable event dispatching		EventDispatcher.initialize(this);				myDragObjects = new Array();				targetList = new Array();				initialPosition = new Object();				_currentState = "none"				_workingDepth = DEFAULTDEPTH;				_makeCopy = false;				myDepthManager = new JSDepthManager();				JSMouseManager.getInstance().addListener(this);			}		////////////////////////////////////////////////////////////////////////////////	//	// Public Methods	//	////////////////////////////////////////////////////////////////////////////////		/**	* Registers an object with this class.	* @param theObject A reference to the Object.	* @param theProxy An optional reference to a proxy Object.	*/	public function registerDragObject(theObject:MovieClip, theProxy:MovieClip) {				if (theProxy == undefined) {						theProxy = theObject;					}				myDragObjects.push({object:theObject, proxy:theProxy});				JSMouseManager.getInstance().addTarget(theObject);				myDepthManager.registerDepthObject(theObject);			}		/**	* Unregisters an object with this class.	* @param theObject A reference to the Object.	*/	public function unregisterDragObject(theObject:MovieClip) {				for (var i = 0; i < myDragObjects.length; i++) {						if (myDragObjects[i].object == theObject) {								JSMouseManager.getInstance().removeTarget(theObject);								myDepthManager.unregisterDepthObject(theObject);							}					}			}		/**	* Unregisters all objects with this class.	*/	public function unregisterAllDragObjects() {				for (var i = 0; i < myDragObjects.length; i++) {							JSMouseManager.getInstance().removeTarget(myDragObjects[i].object);							myDepthManager.unregisterDepthObject(myDragObjects[i].object);					}			}		/**	* Adds a drop target with this class.	* @param theObject A reference to the Object.	*/	public function addTarget(theObject:MovieClip) {				targetList.push(theObject);		this.addListener(theObject);			}		/**	* Removes a drop target from this class.	* @param theObject A reference to the Object.	*/	public function removeTarget(theObject:MovieClip) {				for (var i = 0; i < targetList.length; i++) {						if (targetList[i] == theObject) {								this.removeListener(theObject);				targetList.splice(i,1);							}					}			}		/**	* Removes all drop targets from this class.	*/	public function removeAllTargets() {				for (var i = 0; i < targetList.length; i++) {						this.removeListener(targetList[i]);					}				targetList = [];			}					////////////////////////////////////////////////////////////////////////////////	//	// Private Functions	//	////////////////////////////////////////////////////////////////////////////////		////////////////////////////////////////////////////////////////////////////////	//	// Hook Functions	//	////////////////////////////////////////////////////////////////////////////////		public function clone(theObject:MovieClip):MovieClip {				return theObject.duplicateMovieClip("tempDragObject", _workingDepth);			}		////////////////////////////////////////////////////////////////////////////////	//	// Event Handlers	//	////////////////////////////////////////////////////////////////////////////////		private function mouseDownTopmostEvent(theObject) {						for (var i = 0; i < myDragObjects.length; i++) {						if (myDragObjects[i].object == theObject) {								if (myDragObjects[i].proxy.hitTest(_root._xmouse,_root._ymouse,true)) {										_currentState = "dragging";					_currentDragObject = theObject;										initialPosition = {x:theObject._x, y:theObject._y};										if (!_makeCopy) {											myDepthManager.bringToFront(theObject);												theObject.startDrag();												// broadcast a message with a reference to the object						this.broadcastMessage("startDragEvent", theObject);						this.dispatchEvent({type:"startDragEvent", target:this, params:theObject});											} else {												tempDragObject = clone(theObject);						tempDragObject.startDrag();												// broadcast a message with a reference to the object						this.broadcastMessage("startDragEvent", tempDragObject);						this.dispatchEvent({type:"startDragEvent", target:this, params:theObject});											}						}							}					}			}		private function mouseUpEvent() {				if (_currentState == "dragging") {						_currentDragObject.stopDrag();					var tempFlag:Boolean = false;			var tempIndex:Number = 0;						for (var i = 0; i < targetList.length; i++) {								if (targetList[i].hitTest(_root._xmouse,_root._ymouse,true)) {										if (tempFlag) {												// Check to see if the movie is on top and is visible						if (targetList[tempIndex].getDepth() < targetList[i].getDepth() && targetList[i]._visible != false) {														tempIndex = i;													}											} else {							tempFlag = true;						tempIndex = i;											}										// broadcast a message with a reference to the object the mouse is over					this.broadcastMessage("dropEvent", _currentDragObject, targetList[i], {x:initialPosition.x, y:initialPosition.y});					this.dispatchEvent({type:"dropEvent", target:this, params:{object:_currentDragObject, target:targetList[i], position:{x:initialPosition.x, y:initialPosition.y}}});									}							}						// If the object is not dropped over any registered objects...			if (!tempFlag) {								_currentDragObject._x = initialPosition.x;				_currentDragObject._y = initialPosition.y;								// broadcast a message with "none"				this.broadcastMessage("invalidDropEvent", _currentDragObject);				this.dispatchEvent({type:"invalidDropEvent", target:this, params:_currentDragObject});							} else {								//trace("JSMouseManager topmost is "+targetList[tempIndex]);				// broadcast a message with a reference to the topmost object the mouse is over				this.broadcastMessage("dropTopmostEvent", _currentDragObject, targetList[tempIndex], {x:initialPosition.x, y:initialPosition.y});				this.dispatchEvent({type:"dropTopmostEvent", target:this, params:{object:_currentDragObject, target:targetList[tempIndex], position:{x:initialPosition.x, y:initialPosition.y}}});							}						if(_makeCopy) {				tempDragObject.removeMovieClip();			}						initialPosition = {};						_currentState = "none";						this.broadcastMessage("stopDragEvent", _currentDragObject);			this.dispatchEvent({type:"stopDragEvent", target:this, params:_currentDragObject});					}				_currentDragObject = undefined;			}		private function mouseDraggingEvent() {				if (_currentState == "dragging") {						var tempFlag:Boolean = false;			var tempIndex:Number = 0;						for (var i = 0; i < targetList.length; i++) {								if (targetList[i].hitTest(_root._xmouse,_root._ymouse,true)) {										if (tempFlag) {												// Check to see if the movie is on top and is visible						if (targetList[tempIndex].getDepth() < targetList[i].getDepth() && targetList[i]._visible != false) {														tempIndex = i;													}											} else {							tempFlag = true;						tempIndex = i;											}										// broadcast a message with a reference to the object the mouse is over					this.broadcastMessage("hoverEvent", _currentDragObject, targetList[i]);					this.dispatchEvent({type:"hoverEvent", target:this, params:{object:_currentDragObject, target:targetList[i]}});									}							}						// If the object is not hovered over any registered objects...			if (!tempFlag) {								//							} else {								// broadcast a message with a reference to the topmost object the mouse is over				this.broadcastMessage("hoverTopmostEvent", _currentDragObject, targetList[tempIndex]);				this.dispatchEvent({type:"hoverTopmostEvent", target:this, params:{object:_currentDragObject, target:targetList[tempIndex]}});							}						this.broadcastMessage("updateDragEvent", _currentDragObject);			this.dispatchEvent({type:"updateDragEvent", target:this, params:_currentDragObject});					}			}		////////////////////////////////////////////////////////////////////////////////	//	// Getters/Setters	//	////////////////////////////////////////////////////////////////////////////////		/**	* (Read Only) The current state of the Manager. The states are "none" and "dragging".	*/	public function get currentState():String {		return _currentState;	}		/**	* (Read Only) The current Object being dragged.	*/	public function get currentDragObject():MovieClip {		return _currentDragObject;	}		/**	* A Boolean value. If "true" the class will call the clone() hook function to crate	* a duplicate of the drag object and will perform the dragging function on that object.	* If false the object itself will be dragged.	*/	public function get makeCopy():Boolean {		return _makeCopy;	}	public function set makeCopy(theFlag:Boolean) {		_makeCopy = theFlag;	}		/**	* A Number representing a depth that, if makeCopy is "true", the duplicated object will	* be attached to. The Default is 1000.	*/	public function get workingDepth():Number {		return _workingDepth;	}	public function set workingDepth(theDepth:Number) {		_workingDepth = theDepth;	}	}  // Class End