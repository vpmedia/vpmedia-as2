//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework// Copyright 2006 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework Extras// File: JSDepthManager.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Imports////////////////////////////////////////////////////////////////////////////////import mx.events.EventDispatcher;//////////////////////////////////////////////////////////////////////////////////// Class: JSDepthManager///////////////////////////////////////////////////////////////////////////////////*** JumpShip Depth Manager Class. This Class is basically a reworked version of * the mx.behaviors.DepthControl Class but it instead of acting on all mc's in * a target scope, it only acts on Objects that have been registered to it.*/class com.jsjstudios.jumpship.extras.JSDepthManager{		//	// On Stage	//				//	// Properties	//				//	// Assets	//	private var myDepthObjects:Array	// an array of all of the Objects registered										// to this class (in no particular order)			//	// Intervals	//				//	// Constants	//		//	// Functions	//	/**	* This class issues the following events: newBackObjectEvent(target:Object);	* newFrontObjectEvent(target:Object);  	*/	public var addListener:Function;		// Used by AsBroadcaster	public var removeListener:Function;		// Used by AsBRoadcaster	public var broadcastMessage:Function;	// Used by AsBroadcaster to broadcast message		/**	* This class issues the following events: 	* newBackObjectEvent({type:"newBackObjectEvent", target:JSDepthManager, params:Object});     	* newFrontObjectEvent({type:"newFrontObjectEvent", target:JSDepthManager, params:Object});  	*/	public var addEventListener:Function;		// Used by EventDispatcher	public var removeEventListener:Function;	// Used by EventDispatcher	public var dispatchEvent:Function;			// Used by EventDispatcher	public var dispatchQueue:Function;			// Used by EventDispatcher		////////////////////////////////////////////////////////////////////////////////	//	// Constructor	//	////////////////////////////////////////////////////////////////////////////////		function JSDepthManager ()	{				// Define the array of depth objects		myDepthObjects = new Array();				// Initialize AsBroadcaster to enable event broadcasting		AsBroadcaster.initialize(this);				// Initialize EventDispatcher to enable event dispatching		EventDispatcher.initialize(this);			}		////////////////////////////////////////////////////////////////////////////////	//	// Public Methods	//	////////////////////////////////////////////////////////////////////////////////		/**	* Registers an Object which this class will manage.	* @param theObject A reference to the Object to add	*/	public function registerDepthObject(theObject:Object):Void {				// Save the object to the array		myDepthObjects.push(theObject);			}		/**	* Unregisters an Object which this class.	* @param theObject A reference to the Object to unregister	*/	public function unregisterDepthObject(theObject:Object):Void {				// go through all of the registered objects to find this one		for (var i = 0; i < myDepthObjects.length; i++) {						// remove this object from the array			if (theObject == myDepthObjects[i]) {								myDepthObjects.splice(i,1);							}					}			}		/**	* Method for sending an object to the bottom.	* @param theObject A reference to the Object.	*/	public function sendToBack(target:Object):Void {				// Temp variable		var isLowest = false;				// keep on sending this object backward until it's the lowest		while (isLowest == false) {						// send this object backward			sendBackward(target);						// check to see if it's the lowest			isLowest = (target==getInstanceAtLowest());		}				// broadcast an "newBackObjectEvent" message with a reference to the new topmost object		this.broadcastMessage("newBackObjectEvent", target);		this.dispatchEvent({type:"newBackObjectEvent", target:this, params:target});	}		/**	* Method for bringing an object to the front.	* @param theObject A reference to the Object.	*/	public function bringToFront(target:Object):Void {				// temp variable		var isHighest = false;				// keep bringing this object forward until it is the highest		while (isHighest == false) {						// bring this object forward			bringForward(target);						// check to see if it's the highest			isHighest = (target==getInstanceAtHighest());		}				// broadcast an "newFrontObjectEvent" message with a reference to the new topmost object		this.broadcastMessage("newFrontObjectEvent", target);		this.dispatchEvent({type:"newFrontObjectEvent", target:this, params:target});	}		/**	* Method for sending this object one step back.	* @param theObject A reference to the Object.	*/	public function sendBackward(target:Object):Void {				// make sure it's not already at the bottom		if (target!=getInstanceAtLowest()) {						// swap with the next lowest object			target.swapDepths(getInstanceLowerThan(target));		}	}		/**	* Method for bringing this object one step forward.	* @param theObject A reference to the Object.	*/	public function bringForward(target:Object):Void {				// check to make sure it's not already the highest		if (target!=getInstanceAtHighest()) {						// swap with the next highest object 			target.swapDepths(getInstanceHigherThan(target));		}	}		////////////////////////////////////////////////////////////////////////////////	//	// Private Functions	//	////////////////////////////////////////////////////////////////////////////////		// Function for looking at all of the objects and making an array with their	// references and their depth. this array is then sorted according to depth	private function trackDepths():Array {				// temp array		var dOrder:Array=[];				// create an array of all of the objects with the format		// dOrder[{mc:theObject, depth:theDepth}]		for (var i = 0; i < myDepthObjects.length;i++) {			dOrder.push({mc:myDepthObjects[i], depth:myDepthObjects[i].getDepth()});					}				// sort this array according to the depth of each object		dOrder.sort(orderFunc);				// return the sorted array		return dOrder;	}		// This is the sorting function. it looks at two objects in the trackDepths array	// and decides which one has the higher depth	private function orderFunc(a,b):Number {		var depth1 = Number(a.depth);		var depth2 = Number(b.depth);		if (depth1 > depth2) {			return -1;		} else if (depth2 > depth1) {			return 1;		} else {			return 0;		}	}					// Function that returns the lowest depth object	private function getInstanceAtLowest():Object {		var dOrder = trackDepths();		return dOrder[dOrder.length-1].mc;	}		// Function that returns the highest depth object	private function getInstanceAtHighest():Object {		var dOrder = trackDepths();		return dOrder[0].mc;	}		// Function that returns the object one step lower than the object given	private function getInstanceLowerThan(target:Object):Object {				// temp array		var dOrder = trackDepths();				// find out where this object is in the order of depths		for (var i=0; i<dOrder.length; i++) {			if (dOrder[i].mc==target) {				break;			}		}				// return the next lowest one		return dOrder[i+1].mc;	}		// Function that returns the object one step higher than the object given	private function getInstanceHigherThan(target:Object):Object {				// temp array		var dOrder = trackDepths();				// find out where this object is in the order of depths		for (var i=0; i<dOrder.length; i++) {			if (dOrder[i].mc==target) {				break;			}		}				// return the next highest one		return dOrder[i-1].mc;	}		////////////////////////////////////////////////////////////////////////////////	//	// Event Handlers	//	////////////////////////////////////////////////////////////////////////////////				////////////////////////////////////////////////////////////////////////////////	//	// Getters/Setters	//	////////////////////////////////////////////////////////////////////////////////			}  // Class End