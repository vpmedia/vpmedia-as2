//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework// Copyright 2006 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework Extras// File: JSLoadManager.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Imports////////////////////////////////////////////////////////////////////////////////import mx.utils.Delegate;import com.jsjstudios.jumpship.extras.JSSerialGenerator;import mx.events.EventDispatcher;//////////////////////////////////////////////////////////////////////////////////// Class: JSLoadManager///////////////////////////////////////////////////////////////////////////////////** * JumpShip Load Manager Class. This Class manages basic loading for all assets* in a Application from one central location. Dealing with projects that require* a large number of assets to be loaded (especially all at once) can cause some* unpredictable, and annoying, results in some client browsers. This Classes main* function is to make sure loading takes place in a sensible way with each asset* being loaded sequencially. Added advantages are being able to remove items from* the load queue if they are no longer needed. Also the ability to promote items* to the front of the load queue to make sure they load first. This Class* handles both MovieClips and XML loading.*/class com.jsjstudios.jumpship.extras.JSLoadManager{		//	// On Stage	//				//	// Properties	//	private var _status:String;			// current status of the manager			//	// Assets	//	private static var inst:JSLoadManager;		// instance of the singleton class	private var queue:Array;					// the load queue	private var updateQueue:Array;					// the load queue	private var loadManagerMCL:MovieClipLoader;	// MCL	private var loadManagerXML:XML;				// XML	private var loadManagerListener:Object;		// listener object	private var currentTarget:Object;			// target currently being loaded	private var idList:Array;					// the load queue		//	// Intervals	//				//	// Constants	//		//	// Functions	//	/**	* This class issues the following events: 	* loadInitEvent(theTarget);	* loadCompleteEvent( theTarget);	* loadStartEvent(theTarget); 	* loadProgressEvent({target:theTarget, bytesLoaded:theLoadedBytes, bytesTotal:theTotalBytes});	* loadErrorEvent(theTarget);	* xmlLoadEvent({id:currentTarget, xml:loadManagerXML});	*/	public var addListener:Function;		// Used by AsBroadcaster	public var removeListener:Function;		// Used by AsBRoadcaster	public var broadcastMessage:Function;	// Used by AsBroadcaster to broadcast message		/**	* This class issues the following events: 	* loadInitEvent({type:"loadInitEvent", target:JSLoadManager, params:theTarget});	* loadCompleteEvent( {type:"loadCompleteEvent", target:JSLoadManager, params:theTarget});	* loadStartEvent({type:"loadStartEvent", target:JSLoadManager, params:theTarget}); 	* loadProgressEvent({type:"loadProgressEvent", target:JSLoadManager, params:{target:theTarget, bytesLoaded:theLoadedBytes, bytesTotal:theTotalBytes}});	* loadErrorEvent({type:"loadErrorEvent", target:JSLoadManager, params:theTarget});	* xmlLoadEvent({type:"xmlLoadEvent", target:JSLoadManager, params:{id:currentTarget, xml:loadManagerXML}});	*/	public var addEventListener:Function;		// Used by EventDispatcher	public var removeEventListener:Function;	// Used by EventDispatcher	public var dispatchEvent:Function;			// Used by EventDispatcher	public var dispatchQueue:Function;			// Used by EventDispatcher		////////////////////////////////////////////////////////////////////////////////	//	// Constructor	//	////////////////////////////////////////////////////////////////////////////////	function JSLoadManager ()	{				// Initialize AsBroadcaster to enable event broadcasting		AsBroadcaster.initialize(this);				// Initialize EventDispatcher to enable event dispatching		EventDispatcher.initialize(this);				idList = new Array();				queue = new Array();		updateQueue  = new Array();				loadManagerMCL = new MovieClipLoader();				loadManagerListener = new Object();				loadManagerListener.callback = this;				loadManagerListener.onLoadInit = function(theTarget) {						// broadcast an message			this.callback.broadcastMessage("loadInitEvent", theTarget);			this.dispatchEvent({type:"loadInitEvent", target:this, params:theTarget});						this.callback.loadNext();					};		loadManagerListener.onLoadComplete = function(theTarget) {			// broadcast an message			this.callback.broadcastMessage("loadCompleteEvent", theTarget);			this.dispatchEvent({type:"loadCompleteEvent", target:this, params:theTarget});					};						loadManagerListener.onLoadStart = function(theTarget) {			// broadcast an message			this.callback.broadcastMessage("loadStartEvent", currentTarget);			this.dispatchEvent({type:"loadStartEvent", target:this, params:currentTarget});					};		loadManagerListener.onLoadProgress = function(theTarget, theLoadedBytes, theTotalBytes) {						// broadcast an message			this.callback.broadcastMessage("loadProgressEvent", {target:theTarget, bytesLoaded:theLoadedBytes, bytesTotal:theTotalBytes});			this.dispatchEvent({type:"loadProgressEvent", target:this, params:{target:theTarget, bytesLoaded:theLoadedBytes, bytesTotal:theTotalBytes}});					};				loadManagerListener.onLoadError = function(theTarget, theErrCode) {						trace("ATLoadManager - An error has been returned: "+theErrCode+" : while attempting to load the clip "+theTarget);						// broadcast an message			this.callback.broadcastMessage("loadErrorEvent", theTarget);			this.dispatchEvent({type:"loadErrorEvent", target:this, params:theTarget});						trace("Resuming Load Queue...");			this.callback.loadNext();					};				loadManagerMCL.addListener(loadManagerListener);				loadManagerXML = new XML();		loadManagerXML.ignoreWhite = true;				loadManagerXML.onLoad = Delegate.create(this,xmlLoaded);				_status = "stop";			}		////////////////////////////////////////////////////////////////////////////////	//	// Public Methods	//	////////////////////////////////////////////////////////////////////////////////		/**	* Singleton implementation for this class.	* @return A reference to this class instance.	*/	public static function getInstance ():JSLoadManager	{		//		// Return reference to singleton instance		//		if ( inst == null )		{			// create a single instance of the singleton			inst = new JSLoadManager();						return inst;		}		else		{			// instance already exists, return a reference to it			return inst;		}	}		/**	* Adds a MovieClip to the load queue.	* @param theURL A string with the file path.	* @param theTarget The target MC (or depth).	* @param thePriority An optional parameter. If "true" this asset will be placed	* at the front of the queue.	*/	public function addToQueue(theURL:String, theTarget, thePriority:Boolean):Void {				// theTarget is loosely typed because it can refer to a movie clip		// or a number representing the level into which the new movie is to be loaded				if (theURL != undefined && theURL != "" && theTarget != undefined) {			if (_status == "stop") {				if (thePriority) {					queue.splice(0,0,{url:theURL, target:theTarget});				} else {					queue.push({url:theURL, target:theTarget});				}				updateQueue = [];				startQueue();			} else if (_status == "run") {				updateQueue.push({url:theURL, target:theTarget, priority:thePriority});			}					}			}		/**	* Removes an item from the load queue.	* @param theURL A string with the file path.	* @param theTarget The target item.	*/	public function popFromQueue(theURL:String, theTarget):Void {								for (var i = 0; i < queue.length; i++) {						if (queue[i].target == theTarget && queue[i].url == theURL) {								queue.splice(i,1);							}					}				for (var j = 0; j < updateQueue.length; j++) {					if (updateQueue[j].target == theTarget && updateQueue[j].url == theURL) {				updateQueue.splice(j,1);							}					}			}		/**	* Adds an XML object to the load queue.	* @param theURL A string with the file path.	* @param thePriority An optional parameter. If "true" this asset will be placed	* at the front of the queue.	* @returns An id string which can be used to track XML load events	*/	public function addXMLToQueue(theURL:String, thePriority:Boolean):String {				// Create a unique id for this action		var theID = JSSerialGenerator.getInstance().newSerial();				if (_status == "stop") {			if (thePriority) {				queue.splice(0,0,{url:theURL, type:"xml", id:theID});			} else {				queue.push({url:theURL, type:"xml", id:theID});			}			updateQueue = [];			startQueue();		} else if (_status == "run") {			updateQueue.push({url:theURL, type:"xml", id:theID, priority:thePriority});		}				return theID;			}		/**	* Pauses the load queue.	*/	public function pauseQueue():Void {				_status = "stop";			}		/**	* Starts the load queue after it has been paused.	*/	public function startQueue():Void {				_status = "run";		loadNext();			}		/**	* Clears the load queue.	*/	public function clearQueue():Void {				pauseQueue();		currentTarget = null;		queue = [];		updateQueue = [];					}		/**	* Promotes an item to the front of the load queue.	* @param theTarget The target item.	*/	public function promote(theTarget):Void {				// theTarget is loosely typed because it can refer to a movie clip		// or a number representing the level into which the new movie is to be loaded				for (var i = 0; i < queue.length; i++) {						if (queue[i].target == theTarget) {								if (i != 0) {					var tempObject:Object = queue.slice(i, (i+1));															if (_status == "stop") {						queue.splice(0,0,tempObject);						updateQueue = [];						startQueue();					} else if (_status == "run") {						tempObject.priority = true;						updateQueue.push(tempObject);					}				}							}					}			}		/**	* Gets the load progress of a target MovieClip.	* @param theTarget The target item.	*/	public function getProgress(theTarget):Object {				return loadManagerMCL.getProgress(theTarget);			}		/**	* Places an "unload" command in the load queue.	* @param theTarget The target item.	* @param thePriority An optional parameter. If "true" this asset will be placed	* at the front of the queue.	*/	public function unloadClip(theTarget, thePriority:Boolean):Void {				if (_status == "stop") {						loadManagerMCL.unloadClip(theTarget);			updateQueue = [];					} else if (_status == "run") {						updateQueue.push({unload:true, target:theTarget, priority:thePriority});					}			}					////////////////////////////////////////////////////////////////////////////////	//	// Private Functions	//	////////////////////////////////////////////////////////////////////////////////		private function xmlLoaded ():Void {		if (loadManagerXML.loaded) {							// broadcast an message			broadcastMessage("xmlLoadEvent", {id:currentTarget, xml:loadManagerXML});			this.dispatchEvent({type:"xmlLoadEvent", target:this, params:{id:currentTarget, xml:loadManagerXML}});							loadNext();						} else {							trace("ATLoadManager - An error has occured while attempting to load the xml");						}				}		private function loadNext():Void {				if (_status = "run") {						if (updateQueue.length > 0) {				for (var i = 0; i < updateQueue.length; i++) {										if (updateQueue[i].priority == true) {												queue.splice(0,0,updateQueue[i]);											} else {												queue.push(updateQueue[i]);											}									}							}						updateQueue = [];						if (queue.length > 0) {							if (queue[0].unload == undefined || queue[0].unload == false) {										if (queue[0].type == "xml") {						loadManagerXML.load(queue[0].url);						currentTarget = queue[0].id;						delete idList[queue[0].id];					} else {						//trace(String("loading "+queue[0].target));						loadManagerMCL.loadClip(queue[0].url,queue[0].target);						currentTarget = queue[0].target;					}										queue.splice(0,1);									} else {					//trace(String("unloading "+queue[0].target));					currentTarget = null;					loadManagerMCL.unloadClip(queue[0].target);										queue.splice(0,1);										loadNext();				}															} else {								pauseQueue();							}					}			}		////////////////////////////////////////////////////////////////////////////////	//	// Event Handlers	//	////////////////////////////////////////////////////////////////////////////////				////////////////////////////////////////////////////////////////////////////////	//	// Getters/Setters	//	////////////////////////////////////////////////////////////////////////////////		public function get status():String {				return _status;			}	}  // Class End