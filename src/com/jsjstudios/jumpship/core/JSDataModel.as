//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework// Copyright 2006 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework// File: JSDataModel.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Imports////////////////////////////////////////////////////////////////////////////////import com.jsjstudios.jumpship.core.JSDataRecord;import mx.events.EventDispatcher;////////////////////////////////////////////////////////////////////////////////////// Class: JSDataModel////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Future Additions:// The goal is for the JSDataModel class to be compliant with the DataProvider// API so it can be used with Flash Components.// To be compliant the following methods need to be more fully implemented://// sortItems([compareFunc], [optionsFlag])// sortItemsBy(fieldName, optionsFlag)//// modelChanged event/////////////////////////////////////////////////////////////////////////////////////*** Data Model Class.*/class com.jsjstudios.jumpship.core.JSDataModel{	// 	// On Stage	//				// 	// Properties	//		private var _hasOne:Array;	private var _hasMany:Array;		// 	// Assets	//	private var itemsList:Array;	private var titlesList:Array;		// 	// Constants	//	private var IDCOUNTER:Number = 0;		//	// Functions	//	/**	* This class issues the following events:	* dataModelBindingEvent(dataModelReference, {id:theRecord.id , name:fieldName, value:theRecord.fieldName});  	*/	public var addListener:Function;		// Used by AsBroadcaster	public var removeListener:Function;		// Used by AsBRoadcaster	public var broadcastMessage:Function;	// Used by AsBroadcaster to broadcast message		/**	* This class issues the following events: 	* modelChanged({type:"newBackObjectEvent", target:JSDepthManager, eventName:eventName, firstItem:index, lastItem:index, removedIDs:array, fieldName:name});	*/	public var addEventListener:Function;		// Used by EventDispatcher	public var removeEventListener:Function;	// Used by EventDispatcher	public var dispatchEvent:Function;			// Used by EventDispatcher	public var dispatchQueue:Function;			// Used by EventDispatcher	////////////////////////////////////////////////////////////////////////////	//	// Constructor	//	////////////////////////////////////////////////////////////////////////////	function JSDataModel ( theNames:Array, theItems:Array )	{				// Initialize AsBroadcaster to enable event broadcasting		AsBroadcaster.initialize(this);				// Initialize EventDispatcher to enable event dispatching		EventDispatcher.initialize(this);				// The titlesList is used to keep track of the column names		// and the column order. The JSDataRecord objects don't care		// how their attributes (column items) are ordered so this		// is somewhat artificial but it helps to visualize				titlesList = new Array();				itemsList = new Array();				_hasOne = new Array();				_hasMany = new Array();				if (theNames != undefined) {						titlesList = theNames;					}				if (theItems != undefined) {						for (var i = 0; i < theItems.length; i++) {								addItem(theItems[i]);							}					}									}		////////////////////////////////////////////////////////////////////////////	//	// Public Methods	//	////////////////////////////////////////////////////////////////////////////		/**	* Adds a column to the Model	* @param theName A string with the name of the new column	* @param theValues An object with which to populate the new column. Takes the form	* { id:value, id:value, id:value, ... }	* @see public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void	* @see public function updateColumn(theName:String, theValues:Object):Void	* @see public function removeColumn(theName:String):Void	* @see public function removeColumnAt(theIndex:Number):Void	* @see public function getColumn(theName:String):Object	* @see public function getColumnAt(theIndex:Number):Object	*/	public function addColumn(theName:String, theValues:Object):Void {				// theValues is an object to populat the new column. It should take the		// form { id:value, id:value, id:value }				titlesList.push(theName);				for (var i = 0; i < itemsList.length; i++) {						itemsList[i].addAttribute(theName, theValues[itemsList[i].id]);					}			}		/**	* Adds a column to the Model at a specific location	* @param theName A string with the name of the new column	* @param theIndex A number (zero indexed) that specifies where to add the column	* @param theValues An object with which to populate the new column. Takes the form	* { id:value, id:value, id:value, ... }	* @see public function addColumn(theName:String, theValues:Object):Void	* @see public function updateColumn(theName:String, theValues:Object):Void	* @see public function removeColumn(theName:String):Void	* @see public function removeColumnAt(theIndex:Number):Void	* @see public function getColumn(theName:String):Object	* @see public function getColumnAt(theIndex:Number):Object	*/	public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void {				// theValues is an object to populat the new column. It should take the		// form { id:value, id:value, id:value }				titlesList.splice(theIndex,0,theName);				for (var i = 0; i < itemsList.length; i++) {						itemsList[i].addAttribute(theName, theValues[itemsList[i].id]);					}			}		/**	* Updates a column with the values provided.	* @param theName A string with the name of the new column	* @param theValues An object with which to populate the new column. Takes the form	* { id:value, id:value, id:value, ... }	* @see public function addColumn(theName:String, theValues:Object):Void	* @see public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void	* @see public function removeColumn(theName:String):Void	* @see public function removeColumnAt(theIndex:Number):Void	* @see public function getColumn(theName:String):Object	* @see public function getColumnAt(theIndex:Number):Object	*/	public function updateColumn(theName:String, theValues:Object):Void {				// theValues is an object to populat the new column. It should take the		// form { id:value, id:value, id:value }				for (var i = 0; i < itemsList.length; i++) {						itemsList[i].update(theName, theValues[itemsList[i].id]);					}				this.dispatchEvent({type:"modelChanged", target:this, eventName:"updateColumn"});			}		/**	* Removes a column.	* @param theName A string with the name of the new column	* @see public function addColumn(theName:String, theValues:Object):Void	* @see public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void	* @see public function updateColumn(theName:String, theValues:Object):Void	* @see public function removeColumnAt(theIndex:Number):Void	* @see public function getColumn(theName:String):Object	*/	public function removeColumn(theName:String):Void {						for (var i = 0; i < itemsList.length; i++) {						itemsList[i].removeAttribute(theName);					}				for (var j = 0; j < titlesList.length; j++) {						if (titlesList[j] == theName) {								titlesList.splice(j,1);							}					}			}		/**	* Removes a column at the specified index.	* @param theIndex A number (zero indexed) that specifies which column to remove	* @see public function addColumn(theName:String, theValues:Object):Void	* @see public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void	* @see public function updateColumn(theName:String, theValues:Object):Void	* @see public function removeColumn(theName:String):Void	* @see public function getColumn(theName:String):Object	* @see public function getColumnAt(theIndex:Number):Object	*/	public function removeColumnAt(theIndex:Number):Void {				var theName:String = titlesList[theIndex];				titlesList.splice(theIndex,1);						for (var i = 0; i < itemsList.length; i++) {						itemsList[i].removeAttribute(theName);					}				}		/**	* Returns the values of a column in the form of an object.	* @param theName A string with the name of the new column	* @return an object containing the column values in the form { id:value, id:value, id:value, ... }	* @see public function addColumn(theName:String, theValues:Object):Void	* @see public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void	* @see public function updateColumn(theName:String, theValues:Object):Void	* @see public function removeColumn(theName:String):Void	* @see public function removeColumnAt(theIndex:Number):Void	* @see public function getColumnAt(theIndex:Number):Object	*/	public function getColumn(theName:String):Object {				// tempObj takes the form { id:value, id:value, id:value }				var tempObj = new Object();				for (var i = 0; i < itemsList.length; i++) {						tempObj[itemsList[i].id] = itemsList[i][theName];					}				return tempObj;			}		/**	* Returns the values of a column in the form of an object.	* @param theIndex A number (zero indexed) that specifies which column to return	* @return an object containing the column values in the form { id:value, id:value, id:value, ... }	* @see public function addColumn(theName:String, theValues:Object):Void	* @see public function addColumnAt(theName:String, theIndex:Number, theValues:Object):Void	* @see public function updateColumn(theName:String, theValues:Object):Void	* @see public function removeColumn(theName:String):Void	* @see public function removeColumnAt(theIndex:Number):Void	* @see public function getColumn(theName:String):Object	*/	public function getColumnAt(theIndex:Number):Object {				// tempObj takes the form { id:value, id:value, id:value }				var tempObj = new Object();				for (var i = 0; i < itemsList.length; i++) {						tempObj[itemsList[i].id] = itemsList[i][titlesList[theIndex]];					}				return tempObj;			}		/**	* Returns the data record at a given index.	* @param theIndex A number (zero indexed) that specifies which record to return	* @return A reference to the data record	*/	public function getItemAt(theIndex:Number):JSDataRecord {				return itemsList[theIndex];			}		/**	* Returns the data record id at a given index.	* @param theIndex A number (zero indexed) that specifies which record id to return	* @return The id number of the data record	*/	public function getItemID(theIndex:Number):Number {				return itemsList[theIndex].id;			}		/**	* Returns the data record at a given index.	* @param theIndex A number (zero indexed) that specifies which record to return	* @param theFieldName The attribute (column) name for the field to return	* @return A reference to the data record	*/	public function getEditingData(theIndex:Number, theFieldName:String):Object {				return itemsList[theIndex][theFieldName];			}		/**	* Adds a new record item to the Model.	* @param theItem A JSDataRecord to add	* @see public function addItemAt(theIndex:Number, theItem:JSDataRecord):Void	*/	public function addItem(theItem:JSDataRecord):Void {				itemsList.push(theItem);				theItem.addListener(this);				// Make sure the item has all of the columns in this model		for (var i = 0; i < titlesList.length; i++) {						if (theItem[titlesList[i]] == undefined) {								theItem.addAttribute(titlesList[i]);							}					}				// also give this item an id		theItem.addAttribute("id", IDCOUNTER);				IDCOUNTER++;				this.dispatchEvent({type:"modelChanged", target:this, eventName:"addItems", firstItem:(itemsList.length-1), lastItem:(itemsList.length-1), removedIDs:[], fieldName:""});			}		/**	* Adds a new record item to the Model at a specified index.	* @param theIndex The index (zero indexed) where the item is to be added	* @param theItem A JSDataRecord to add	* @see public function addItem(theItem:JSDataRecord):Void	*/	public function addItemAt(theIndex:Number, theItem:JSDataRecord):Void {				theItem.addListener(this);				for (var j = 0; j < itemsList.length; j++) {						if (itemsList[j].id == theIndex) {								itemsList[j].destroy();								itemsList[j].splice(j,1);							}					}				itemsList.push(theItem);				// Make sure the item has all of the columns in this model		for (var i = 0; i < titlesList.length; i++) {						if (theItem[titlesList[i]] == undefined) {								theItem.addAttribute(titlesList[i]);							}					}				// also give this item an id		theItem.addAttribute("id", theIndex);				this.dispatchEvent({type:"modelChanged", target:this, eventName:"addItems", firstItem:theIndex, lastItem:theIndex, removedIDs:[], fieldName:""});			}		/**	* Serch and sort method for record items.	* @param theMethod The search method, "all" or "first"	* @param theConditions An optional object the limits the search to the name-value pairs that are given.	* theConditions takes the form {name1:value1, name2:value2, ... }. In plain english this conducts a 	* search where the column "name1" has the value "value1" and the column "name2" has the value "value2"	* @param theOptions One or more optional string parameters that either limits the results or specifies	* an order to return them. THIS FEATURE HAS NOT YET BEEN IMPLEMENTED.	*/	public function find(theMethod:String) {				// Planed arguments[x] parameters		//* :order: An SQL fragment like "created_at DESC, name".		//* :limit: An integer determining the limit on the number of rows that should be returned.		//* :offset: An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.		//* :include: Names associations that should be loaded alongside using LEFT OUTER JOINs. The symbols named refer to already defined associations. See eager loading under Associations.				// this function will match the object param and value with the		// list of items. If there is more than one param/value pair, it will		// be treated as an AND search.				// arguments[0] can either be "all" or "first" which indicates whether		// to return all of the results or just the first.				// Make sure the item has all of the columns in this model				var orderFlag:Boolean = false;		var limitFlag:Boolean = false;		var offsetFlag:Boolean = false;		var includeFlag:Boolean = false;				for (var i = 2; i < arguments.length; i++) {						for (var a in arguments[i]) {								switch (a) {										case "order":						orderFlag = true;						//trace(a);						break;					case "limit":						limitFlag = true;						//trace(a);						break;					case "offset":						offsetFlag = true;						//trace(a);						break;					case "include":						includeFlag = true;						//trace(a);						break;					default:						break;										}							}					}				if (arguments[0] == "all") {						var tempArray:Array = new Array();			for (var k = 0; k < itemsList.length; k++) {				tempArray.push(itemsList[k]);			}						for (var a in arguments[1]) {							for (var i = 0; i < tempArray.length; i++) {									if (tempArray[i][a] != arguments[1][a]) {												tempArray.splice(i,1);												i--;											}									}							}						return tempArray;								} else if (arguments[0] == "first") {						var tempFlag = false;						for (var i = 0; i < itemsList.length; i++) {								tempFlag = true;								for (var a in arguments[1]) {									if (itemsList[i][a] != arguments[1][a]) {												tempFlag = false;											}									}								if (tempFlag) {										return itemsList[i];										break;									}							}					}					}		/**	* Sorts the Records in this model and changes the id's accordingly.	* @param theCompareFunction An optional reference to a compare function.	* See the Array.sort method in the Flash docs for details. If no functino is given	* the default is to sort alphabetically by the first column	* @see public function sortItemsBy():Void	*/	public function sortItems():Void {				if (arguments[0] != undefined) {						var compareFunc:Function = arguments[0];					} else {						var compareFunc:Function = sortCompare;					}				var tempIndex:Number				for (var i = 0; i < itemsList.length; i++) {						for (var j = 0; j < itemsList.length; j++) {								if (i > j && !compareFunc.call(itemsList[i], itemsList[j])) {										if (tempIndex == undefined) {												tempIndex = i;											}					var tempItem1 = itemsList[i];					var tempItem2 = itemsList[j];										itemsList[i] = tempItem2;					itemsList[j] = tempItem1;									}							}					}				this.dispatchEvent({type:"modelChanged", target:this, eventName:"sort", firstItem:tempIndex, lastItem:(itemsList.length-1), removedIDs:[], fieldName:""});			}		/**	* Sorts the Records in this model according to a column and changes the id's accordingly.	* @param fieldName The name of the column to sor by.	* @see public function sortItems():Void	*/	public function sortItemsBy(fieldName:String):Void {				var tempIndex:Number				for (var i = 0; i < itemsList.length; i++) {						for (var j = 0; j < itemsList.length; j++) {								if (i > j && !sortCompare(itemsList[i], itemsList[j], fieldName)) {										if (tempIndex == undefined) {												tempIndex = i;											}																	   					var tempItem1 = itemsList[i];					var tempItem2 = itemsList[j];										itemsList[i] = tempItem2;					itemsList[j] = tempItem1;									}							}					}				this.dispatchEvent({type:"modelChanged", target:this, eventName:"sort", firstItem:tempIndex, lastItem:(itemsList.length-1), removedIDs:[], fieldName:fieldName});			}		/**	* Removes all record items from the Model.	* @see public function remove(theIndex:Number):Void	*/	public function removeAll():Void {				var tempArray:Array = new Array();				var tempIndex:Number = itemsList.length-1;						for (var i = 0; i < itemsList.length; i++) {						tempArray.push(itemsList[i].id);						itemsList[i].destroy();					}					itemsList = [];		titlesList = [];		IDCOUNTER = 0;				this.dispatchEvent({type:"modelChanged", target:this, eventName:"removeItems", firstItem:0, lastItem:tempIndex, removedIDs:tempArray});			}		/**	* Alias for the remove() method. Removes a record item at the specified index.	* @param theIndex The index (zero indexed) of the item to be removed	* @see public function removeAll():Void	*/	public function removeItemAt(theIndex:Number):Void {				remove(theIndex);			}		/**	* Removes a record item at the specified index.	* @param theIndex The index (zero indexed) of the item to be removed	* @see public function removeAll():Void	*/	public function remove(theIndex:Number):Void {				this.dispatchEvent({type:"modelChanged", target:this, eventName:"removeItems", firstItem:theIndex, lastItem:theIndex, removedIDs:[itemsList[theIndex]]});				itemsList[theIndex].destroy();				itemsList.splice(theIndex,1);		titlesList.splice(theIndex,1);		IDCOUNTER--;			}		/**	* Replaces a record item at the specified index.	* @param theIndex The index (zero indexed) of the item to be replaced	* @param theItem A JSDataRecord that will replace the old one	*/	public function replaceItemAt(theIndex:Number, theItem:JSDataRecord):Void {				removeItemAt(theIndex);		  		addItemAt(theIndex, theItem);			}				/**	* Updates a record item at the specified index.	* @param theIndex The index (zero indexed) of the item to be updated	* @param theAttributes The name-value pairs for the updated item. Takes the form 	* {columnName1:value1, columnName2:value2, ... }	* @see public function updateAll(theAttributes:Object, theConditions:Object)	*/	public function update(theIndex:Number, theAttributes:Object) {				itemsList[theIndex].update(theAttributes);			}		/**	* Updates an attribute of a record item at the specified index.	* @param theIndex The index (zero indexed) of the item to be updated	* @param theFieldName The attribute (column) name for the field to update	* @param newData The new data for the record attribute	*/	public function editField(theIndex:Number, theFieldName:String, newData) {				itemsList[theIndex][theFieldName] = newData;			}		/**	* Updates all record items.	* @param theAttributes The name-value pairs for the updated item. Takes the form 	* {columnName1:value1, columnName2:value2, ... }	* @param theConditions The optional conditions that determine which items to update.	* theConditions takes the form {name1:value1, name2:value2, ... }. In plain english this conducts a 	* search where the column "name1" has the value "value1" and the column "name2" has the value "value2"	* @see public function updateAll(theAttributes:Object, theConditions:Object)	*/	public function updateAll(theAttributes:Object, theConditions:Object) {				var tempArray:Array = this.find("all", theConditions);				for (var i = 0; i < tempArray.length; i++) {						tempArray[i].update(theAttributes);					}				this.dispatchEvent({type:"modelChanged", target:this, eventName:"updateAll"});			}		////////////////////////////////////////////////////////////////////////////	//	// Hook Methods	//	////////////////////////////////////////////////////////////////////////////			////////////////////////////////////////////////////////////////////////////	//	// Private Methods	//	////////////////////////////////////////////////////////////////////////////		// The default sort compare function compares two records	private function sortCompare(a,b, fieldName:String) {				// By default this function compares the first column		if (fieldName == undefined) {						fieldName = titlesList[0];					}				if (typeof(a[fieldName]) == "number") {						return a[fieldName] > b[fieldName];					} else {						return a[fieldName].toUpperCase() > b[fieldName].toUpperCase();					}			}		////////////////////////////////////////////////////////////////////////////	//	// Event Handlers	//	////////////////////////////////////////////////////////////////////////////	private function dataRecordBindingEvent(theRecord:JSDataRecord, theName:String) {				this.broadcastMessage("dataModelBindingEvent", this, {id:theRecord["id"] , name:theName, value:theRecord[theName]});				var tempIndex:Number = 0;				for (var i = 0; i < itemsList.length; i++) {						if (itemsList[i] == theRecord) {								tempIndex = i;							}					}				this.dispatchEvent({type:"modelChanged", target:this, eventName:"updateField", firstItem:tempIndex, lastItem:tempIndex, removedIDs:[], fieldName:theName});			}	////////////////////////////////////////////////////////////////////////////	//	// Getter/Setters	//	////////////////////////////////////////////////////////////////////////////	/**	* An array containing the names of the columns in this Model	*/	public function get columnNames():Array {				return titlesList;			}		public function set columnNames(theNames:Array):Void {				titlesList = theNames;				// Make sure the item has all of the columns in this model		for (var i = 0; i < titlesList.length; i++) {						for (var j = 0; j < itemsList.length; j++) {							if (itemsList[j][titlesList[i]] == undefined) {										itemsList[j].addAttribute(titlesList[i]);									}							}					}			}		/**	* (Read Only) The number of record items in this Model	*/	public function get length():Number {				return itemsList.length;			}		/**	* (Read Only) An array of all record items in this Model. Same as records property.	*/	public function get items():Array {				return itemsList;			}		/**	* (Read Only) An array of all record items in this Model. Same as items property.	*/	public function get records():Array {				return itemsList;			}		/**	* An array referencing other Models that this Model has a "has one" relationship	* to.	* @see hasMany	*/	public function get hasOne():Array {				return _hasOne;			}	public function set hasOne(theArray:Array):Void {				_hasOne = theArray;			}		/**	* An array referencing other Models that this Model has a "has many" relationship	* to.	* @see hasOne	*/	public function get hasMany():Array {				return _hasMany;			}	public function set hasMany(theArray:Array):Void {				_hasMany = theArray;			}		}	// Class End