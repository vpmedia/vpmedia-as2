//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework// Copyright 2006 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework// File: JSCommandBase.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Imports////////////////////////////////////////////////////////////////////////////////// none////////////////////////////////////////////////////////////////////////////////////// Class: JSCommandBase/////////////////////////////////////////////////////////////////////////////////////*** Command Base Class. In this framework commands have the ability to cascade or* call other commands. Therefore this base class contains a lot of the same* methods as the Controller base class. But whereas the Controller MUST implement* primitive command functions, commands are not required to.*/class com.jsjstudios.jumpship.core.JSCommandBase{	//	// Properties	//	private var _owner:Object;	private var _id:String;		//	// Assets	//	private var parameters:Object;	private var resultObject:Object;		// Reference to the view for this command. This is *not* strongly typed on	// purpose since we don't know the exact type of the view even at runtime	private var viewRef;		private var commands:Object;			// holds named list of commands		private var commandLog:Array;			// log of commands	private var commandHistory:Array;		// history of commands		private var viewLookupTable:Array;		// An associative array of commands and their corresponding views		//	// CONSTANTS	//	/** 	* Constant: The Name Of thie Command. This constant should be overwritten by 	* extending classes.	*/	private var COMMANDNAME:String = "JSCommandBase";		// this value should be overwritten															// with the proper name	/** 	* Constant: Determines the maximum number of commands this command will remember	* in it's history.	*/	private var MAXHISTORY:Number = 100;	// maximum number of history entries			////////////////////////////////////////////////////////////////////////////	//	// Constructor	//	////////////////////////////////////////////////////////////////////////////		function JSCommandBase ()	{				commands = new Object();		commandLog = new Array();		commandHistory = new Array();				viewLookupTable = new Array();				// Hook Operation		preCommandInit();				// Hook Operation		addCommands();				// Hook Operation		init();			}	////////////////////////////////////////////////////////////////////////////	//	// Primitive operations (*must* be overriden)	//	////////////////////////////////////////////////////////////////////////////		/** 	* Called when the execute() method is called on this command. This is a primitive function 	* and must be implemented by extending classes.	* @throws Error If this function is not imlemented by the extending class	*/	public function executeOperation ()	{		throw new Error ("ERROR JSCommandBase - Command "+COMMANDNAME+" did not implement primitive operation executeOperation(). No behavior defined for command.");	}	/** 	* Called when this command has completed it's operations. This is a primitive function 	* and must be implemented by extending classes. It must also call this.onResult(theResultParams)	* to notify the owner that this command has completed.	* @throws Error If this function is not imlemented by the extending class	*/	public function onResultOperation ()	{		throw new Error ("ERROR JSCommandBase - Command "+COMMANDNAME+" did not implement primitive operation onResultOperation().");				// This operation must return a result even if the result is empty.		this.onResult ();	}		/** 	* An optional status handler which can be implemented by extending classes	*/	public function onStatusOperation () {}	////////////////////////////////////////////////////////////////////////////	//	// Hook Operations	//	////////////////////////////////////////////////////////////////////////////		private function preCommandInit(){}		private function init(){}		private function beforeFilter(theCommandName:String){}		private function afterFilter(theCommandName:String){}		private function addCommands () 	{		//		// Note: Commands are added as references to the classes. Dispatching 		// a command includes creating an instance of it, which is then kept		// in a history log on the controller. The command is automatically 		// removed after the service has returned (so we don't have a memory leak).		//		// The general format should be:		//		// addCommand ( "getPersonListCommand", GetPersonListCommand );	}		private function processCommandResult(theResultObject:Object) 	{				// theResultObject will be in the form:		// theResultObject.type : String - the name of the command returning the result		// theResultObject.result : Object - the actual result			}		////////////////////////////////////////////////////////////////////////////	//	// Concrete operations	//	////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////	// execute()	////////////////////////////////////////////////////////////////////////////	/** 	* Executes this command. After storing the necessary parameters it will call	* the onExecuteOperation() method to carry out the main functionality	* @param theParent A reference to the owner of this command.	* @param theID A string with an ID that is passed back to the owner upon completion.	* @param theParams An object containing parameters that the owner passes to this	* command.	* @see public function executeOperation ()	* @throws Error If this function is not imlemented by the extending class	*/	public function execute (theParent:Object, theID:String, theParams:Object)	{		resultObject = new Object();				if (theParent != undefined) {			_owner = theParent;		} else {			throw new Error ("ERROR Command "+COMMANDNAME+" did not receive the proper parameters upon instantiation. The owner was not given or is undefined.");		}							if (theID != undefined) {			_id = theID;		} else {			throw new Error ("ERROR Command "+COMMANDNAME+" did not receive the proper parameters upon instantiation. The id was not given or is undefined.");		}				if (theParams != undefined) {			parameters = theParams;		} else {			throw new Error ("ERROR Command "+COMMANDNAME+" did not receive the proper parameters upon instantiation. The parameters object was not given or is undefined.");		}				if (theParams != undefined && theID != undefined && theParent != undefined) {						viewRef = _owner.requestView(COMMANDNAME);						executeOperation();					}	}		/** 	* Returns the result of a command. This method calls the afterFilter() hook method 	* and removes command object. This method then calls the processCommandResult 	* primitive method with the result.	* @param theResultObject An object containing the result information from the command.	* @param theID A String with the ID of the command returning the result.	*/	public function returnCommandResult(theResultObject:Object, theID:String) 	{				afterFilter(theResultObject.type);				// Free up memory		delete commandLog[theID];		commandLog[theID] = undefined;				processCommandResult(theResultObject); 			}		/** 	* Returns a reference to the View that is associated with a given command.	* @param theCommandName A string with the name of the class requesting a reference.	* @throws Error If the command name has not been registered with this controller	* @return A reference to the view associated with this command. 	*/	public function requestView ( theCommandName:String ) 	{				if ( commands [ theCommandName ] != undefined ) {			return viewLookupTable[ theCommandName ];		} else {			throw new Error ("ERROR The command "+theCommandName+" is trying to perform an command but is not registered with the Controller.");		}			}		////////////////////////////////////////////////////////////////////////////	//	// Private Functions	//	////////////////////////////////////////////////////////////////////////////		private function addCommand ( commandName:String, commandRef:Function) 	{				if ( commands [ commandName ] != undefined ) {			throw new Error ("ERROR The command "+commandName+" has already been added to the Controller.");		} else {			commands [ commandName ] = commandRef;		}	}		private function createCommand(theCommandName:String, theParams:Object) 	{				// Create a unique id for this command		var tempDate:Date = new Date();		var idNum:Number = Date.UTC(tempDate.getFullYear(),tempDate.getMonth(), tempDate.getDate(), tempDate.getHours(), tempDate.getMinutes(), tempDate.getSeconds(), tempDate.getMilliseconds());		var idString:String = String(idNum);				// Check to see if this id already exists		while (commandLog[idString] != undefined) {						// if so increment the id number			idNum++;			idString = String(idNum);					}				beforeFilter(theCommandName)				commandLog[idString] = new commands [ theCommandName ]();		commandHistory.push({name:theCommandName, params:theParams});				// to prevent a memory leak, limit the size of the array to MAXHISTORY		while (commandHistory.length > MAXHISTORY) {						commandHistory.splice(0,1);					}				commandLog[idString].execute(this, idString, theParams);				}	////////////////////////////////////////////////////////////////////////////	//	// Concrete event handlers. (Most Commands will call service functions    // and we anticipate this behavior by implementing skeleton onStatus and	// onResult event handlers.)	//	////////////////////////////////////////////////////////////////////////////	////////////////////////////////////////////////////////////////////////////	// onStatus()	////////////////////////////////////////////////////////////////////////////	public function onStatus ( statusObj )	{				//trace ("STATUS Command::onStatus");		// print out trace of error, including Java stack trace if applicable		//for ( var i in statusObj )		//{			//trace ( i + " = " + statusObj[i] );		//}		// hook operation 		onStatusOperation( statusObj );	}		////////////////////////////////////////////////////////////////////////////	// onResult()	////////////////////////////////////////////////////////////////////////////	public function onResult ( resultObj )		{		resultObject.type = COMMANDNAME;					// The onResult Handler can receive no parameters in which case 		// resultObject.result will be undefined		resultObject.result = resultObj;				_owner.returnCommandResult(resultObject, _id);			}		////////////////////////////////////////////////////////////////////////////	//	// Getters / Setters	//	////////////////////////////////////////////////////////////////////////////		/**	* (Read Only) A Reference to the owner (caller) of this command.	*/	public function get owner():Object 	{		return _owner;	}		/**	* (Read Only) This command's ID as given by the execute() parameters of the owner.	*/	public function get id():String 	{		return _id;	}	}