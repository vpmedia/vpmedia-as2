/** * com.sekati.kernel.Logger * @version 2.0.0 * @author jason m horwitz | sekati.com | tendercreative.com * Copyright (C) 2007  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */ import com.sekati.time.StopWatch;import com.sekati.kernel.Inspector;import com.sekati.kernel.LCBinding;import com.sekati.kernel.LogEvent;import com.sekati.net.NetBase;import com.sekati.reflect.Stringifier;import com.sekati.validate.FlashValidation;/** * Logger is a multi-tiered debugging tool designed to clarify the debugging process. *  * The Logger consists of two main tiered components: * 	- "levels" (method calls, i.e. 'trace', 'info', 'status', etc). * 	- "filters" (origin of the level call, i.e. '_root', 'myClassInstance', 'myMc', etc). * 	 * New level method calls may be created dynamically "overloading" the singleton class  * via {@link setLevel}, __resolve & proxy as illustrated in the exam	ple usage below. * NOTE: custom levels/overloading requires publishing >= Flash 9. *  * Logger can be configured to display its output to the  {@link Console} or Flash IDE  * Output Panel via: * {@code Logger.$.ide = true; * 	Logger.$.console = true; * } *  * {@code Usage: * 	Logger.$.trace( this, "Hello World!" ); * 	Logger.$.setLevel( "sekati", true ); * 	Logger.$.sekati( this, "I created a new level!" ); * 	Logger.$.setLevel("sekati", false ); * 	Logger.$.sekati( this, "on noes; you wont see this cuz the level is disabled!" ); * 	Logger.$.setFilter ( this, true ); * 	Logger.$.status ( this, "oh noes; you wont see this cuz the origin is filtered!" ); * } *  * @see {@link com.sekati.log.Console} */class com.sekati.kernel.Logger {	private static var _instance:Logger;	private var _logId:Number;	private var _logEnable:Boolean;	private var _logIDE:Boolean;	private var _logConsole:Boolean;	private var _proxyObj:Object;	private var _levels:Object;	private var _filters:Array;	private var _watch:StopWatch; 		// default level stubs	public var trace:Function;	public var debug:Function;	public var info:Function;	public var notice:Function;	public var status:Function;	public var warn:Function;	public var error:Function;	public var fatal:Function;		/**	 * Singleton Private Constructor.	 */	private function Logger() {		_logId = 0;		_logEnable = true;		_logIDE = false;		_logConsole = false;		_proxyObj = new Object();		_watch = new StopWatch( true );		resetLevels();		resetFilters();	}	/** 	 * Singleton Accessor.	 * @return Logger	 */	public static function getInstance():Logger {		if (!_instance) _instance = new Logger();		return _instance;	}		/**	 * Shorthand Singleton accessor getter.	 * @return Logger	 */	 public static function get $():Logger {	 	return Logger.getInstance();		 }		// CORE CONTROLLERS		/**	 * enabled getter	 * @return Boolean	 */		public function get enable():Boolean {		return _logEnable;	}			/**	 * enabled setter	 * @param b (Boolean) enable or disable Logger	 */		public function set enable(b:Boolean):Void {		_logEnable = b;	}	/**	 * IDE output getter	 * @return Boolean	 */	public function get ide():Boolean {		return _logIDE;		}		/**	 * IDE output setter	 * @param b (Boolean)	 * @return Void	 */	public function set ide(b:Boolean):Void {		_logIDE = b;		}		/**	 * Console output getter	 * @return Boolean	 */	public function get console():Boolean {		return _logConsole;		}	/**	 * Console output setter	 * @param b (Boolean)	 * @return Void	 */	public function set console(b:Boolean):Void {		_logConsole = b;		}		/**	 * Applications info	 * @return String	 */	public function get _info():String {		var str:String = ". ---------------------------=com.sekati.log.Logger=--------------------------- .";		str += "\nAPP  : \t" + _root._url;		str += "\nENV  : \t" + System.capabilities.version+" \t|\t Online: "+NetBase.isOnline()+" \t|\t Preview: "+FlashValidation.isMoviePreview()+" \t|\t Debug: "+System.capabilities.isDebugger+" \t|\t Type: "+System.capabilities.playerType+" \t|\t Fullscreen Support: "+FlashValidation.hasFullscreenMode();		str += "\nPLAT : \t" + System.capabilities.os+" \t|\t "+System.capabilities.manufacturer+" \t|\t Language: "+System.capabilities.language;		str += "\nDISP : \t" + System.capabilities.screenResolutionX+" x "+System.capabilities.screenResolutionY+" \t|\t "+System.capabilities.screenColor+" \t|\t "+System.capabilities.screenDPI+" DPI \t|\t aspect ratio: "+System.capabilities.pixelAspectRatio;		str += "\n. ----------------------------------------------------------------------------- .";		return ( str );	}	/**	 * level and filter _status getter	 * @return String	 */	public function get _status():String {		var str:String = new String();		var s:String = "\n\t* ";		str += s+"Application:" + _root._url;		str += s+"FlashPlayer: "+ getVersion();		str += s+"Logger enabled: " + enable;		str += s+"IDE Output: " + ide;		str += s+"Console Output: " + console;		str += s+getLevels();		str += s+getFilters();		return ( str );	}	/**	 * reset Out to default levels and filters	 * @return Void	 */	public function reset():Void {		setAllLevels(true);		resetFilters();	}			// LEVEL HANDLER		/**	 * Enable/disable a level and create the level if it does not already exist.	 * @param level (String) level name	 * @param isEnabled (Boolean) enabled status	 * @return Void	 */	public function setLevel(level:String, isEnabled:Boolean):Void {		_levels[level.toLowerCase()] = isEnabled;	}	/**	 * Enable or disable all existing levels.	 * @param isEnabled (Boolean) enabled status	 * @return Void	 */	public function setAllLevels(isEnabled:Boolean):Void {		for (var i:String in _levels) {			setLevel( _levels[i], isEnabled );		}	}		/**	 * Check if an levels output is disabled.	 * @param level (String)	 * @return Boolean	 */	public function isDisabled(level:String):Boolean {		return _levels[level.toLowerCase()];	}		/**	 * Reset all levels (clearing previously created levels)	 * @return Void	 */	public function resetLevels():Void {		_levels = { trace:true, debug:true, info:true, notice:true, status:true, warn:true, error:true, fatal:true, object:true };	}	/**	 * Returns a stringified overview of all levels statuses.	 * @return String	 */	public function getLevels():String {		var a:Array = new Array ();		for (var i:String in _levels) {			a.push( i + ":" + _levels[i].toString() );		}		return "_levels = { " + a.toString() + " };";	}		/**	 * object is a special level (method) which handles object recursion via {@link com.sekati.log.Inspector}	 * @param origin (Object) origin for filtering purposes	 * @param obj (Object) object to be recursed thru Out	 * @return Void 	 */	public function object(origin:Object, obj:Object):Void {		var insp:Inspector = new Inspector( obj, origin );		_output( "OBJECT", origin, insp );	}					// FILTER HANDLERS		/**	 * Enable/disable a filter and create the filter if it does not already exist.	 * @param origin (Object) object to filter on [usually a string]	 * @param isFiltered (Boolean)	 * @return Void	 */	public function setFilter(origin:Object, isFiltered:Boolean):Void {		if (isFiltered) {			filter( origin );		} else {			unfilter( origin );		}	}	/**	 * Returns a stringified overview of all filters statuses.	 * @return String	 */	public function getFilters():String {		return "_filters= [ " + _filters.toString() + " ];";	}	/**	 * Reset all filters (clearing previous filters)	 * @return Void	 */	public function resetFilters():Void {		_filters = [];	}		/**	 * Check if an origin's output is being filtered	 * @param origin (Object) to check.	 * @return Boolean	 */	public function isFiltered(origin:Object):Boolean {		var o:String = String( origin );		for (var i:Number = 0; i < _filters.length; i++) {			if (_filters[i] == o) {				return true;			}		}		return false;	}			/**	 * Add an origin to the filters array.	 * @param origin (Object) to be added.	 * @return Void	 */	private function filter(origin:Object):Void {		var o:String = String( origin );		if (!isFiltered( o )) {			_filters.push ( o );		}	}	/**	 * Remove an origin from the filters array.	 * @param origin (Object) to be removed.	 * @return Void	 */	private function unfilter(origin:Object):Void {		var o:String = String( origin );		for (var i:Number = 0; i < _filters.length; i++) {			if (_filters[i] == o) {				_filters.splice( i, 1 );				break;			}		}	}		// OUTPUT HANDLERS		/**	 * Manges output to {@link Console} and Flash Output Panel.	 * @param level (String)	 * @param origin (Object)	 * @param msg (Object)	 * @return Void	 */	private function _output(level:String, origin:Object, msg:Object):Void {		// validate that we should be outputting this content: Logger enabled, level enabled, origin unfiltered & proper LogEvent.		if (_logEnable == false || _levels[level] == false || isFiltered( origin ) == true || !(level.toLowerCase().indexOf("__get__") <= -1)) {			return;		}		var benchmark:Number = _watch.lap();		var id:Number = _logId++;		var e:LogEvent = new LogEvent( {id:id, type:level.toLowerCase(), origin:String(origin), message:String(msg), benchmark:benchmark} );				// dispatch event to localConnection Console		if(console) {			LCBinding.send( e );		}			if(ide) {			trace( id+"\t"+level.toUpperCase()+"\t"+origin+"\t"+msg+"\t("+benchmark+" ms)" );		}	}		// LEVEL OVERLOADING		/**	 * __resolve catches all wrapper & manually created level methods and processes them thru	 * the proxy and sends to _output; super cool!	 * @param name (String)	 * @return Function	 */	private function __resolve(name:String):Function {		if (name.indexOf( LogEvent.LOG_EVENT ) > 1) {			trace("!!!!!!!!! logger returning: "+name+" reflects: "+Stringifier.stringify(LogEvent));			return;		}		var f:Function = function():Object {			arguments.unshift( name );			return __proxy.apply( _proxyObj, arguments );		};		_proxyObj[name] = f;		return f;	}	/**	 * Reconstruct methods calls and rereoute to output	 * @param name (String)	 * @return Void	 */	private function __proxy(name:String):Void {		arguments.shift ();		var n:String = String( name ).toLowerCase ();		var o:String = String( arguments[0] );		var s:String = String( arguments[1] );		_instance._output( n, o, s );	}			/**	 * Destroy the Singleton instance.	 * @return Void	 */	public function destroy():Void {		_watch.destroy();		LCBinding.disconnect();		for(var i in _instance) {			delete _instance[i];			}		delete _instance;	}			}