/** * com.sekati.effects.TextEffects * @version 1.1.1 * @author jason m horwitz | sekati.com * Copyright (C) 2007  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */import com.sekati.effects.AnimHandler;import com.sekati.utils.StringUtils;import com.sekati.utils.TextUtils;
/** * Static class wrapping various text animation effects */class com.sekati.effects.TextEffects {
	/**	 * Count up any positive numeric value in a text field	 * @param tf (TextField)	 * @param n (Number)	 * @param steps (Number)	 * @param cb (Function)	 * @return Void	 */		public static function counter(tf:TextField, n:Number, steps:Number, cb:Function):Void {		tf.text = "";		var str:String = n.toString( );		var count:Number = 0;		var anim:MovieClip = AnimHandler.create( tf );		anim.onEnterFrame = function():Void {			if (count >= n) {				AnimHandler.destroy( tf );				tf.text = str;			} else {				count += steps;				var tmp:String = "";				for (var i:Number = 0; i < (str.length - count.toString( ).length) ; i++) tmp += "0";				tf.text = tmp + count.toString( );			}		};	}
	/**	 * Easing alpha type in text animation	 * @param tf (TextField) target text	 * @param str (String) string to animate in	 * @param cb (Function) callback	 * @return Void	 */	public static function atype(tf:TextField, str:String, cb:Function):Void {		tf.html = true;		tf._alpha = 0;		var anim:MovieClip = AnimHandler.create( tf );		anim.cursor = 0;		anim.dLen = StringUtils.stripTags( str ).length;		anim.onEnterFrame = function():Void {			if (anim.dLen > 30) {				anim.cursor += 16 + random( 16 );			} else if (anim.dLen > 20) {				anim.cursor += 3 + random( 4 );			} else {				anim.cursor += 1;			}			tf.htmlText = str.substr( 0, anim.cursor );			anim.dLen = StringUtils.stripTags( str ).length - tf.text.length;			tf._alpha = int( tf.text.length * 100 / str.length );			//			if (anim.dLen <= 1) {				anim.destroy( );				tf.htmlText = str;				tf._alpha = 100;				cb( );			}		};	}
	/**	 * easing alpha type out  text animation	 * @param tf (TextField) target text	 * @param cb (Function) callback	 * @return Void	 */	public static function uatype(tf:TextField, cb:Function):Void {		var sLen:Number = tf.htmlText.length;		trace( "uatype " + sLen );		// create anim handler                		var anim:MovieClip = AnimHandler.create( tf );		anim.cursor = tf.htmlText.length;		anim.onEnterFrame = function():Void {			if (anim.cursor == 0) {				//trace ("uatype done");				anim.destroy( );				tf._alpha = 100;				if (cb) {					cb( );				}			} else {				//trace ("running: " + anim.cursor);				anim.cursor -= (40 + random( 25 ));				tf._alpha = int( tf.htmlText.length * 100 / sLen );				if (anim.cursor < 0) {					anim.cursor = 0;					tf._alpha = 0;				}				tf.htmlText = tf.htmlText.substr( 0, anim.cursor );			}		};	}
	/**	 * text animation pushes text into view	 * @param tf (TextField) target text	 * @param str (String) string to animate in	 * @param ms (Number) miliseconds	 * @param htm (Boolean) support htmlText	 * @param cb (Function) callback	 * @return Void	 */	public static function pushtype(tf:TextField, str:String, ms:Number, htm:Boolean, cb:Function):Void {		if (htm == true) {			var hstr:String = str;			str = StringUtils.stripTags( str );			tf.html = true;		}		if (tf.pushing != true) {			tf.pushing = true;			var from:Number = str.length;			tf.wordWrap = true;			var cp:Number = (str.length > 250) ? 26 : Math.floor( str.length / 4 );			if (cp < 1) {				cp = 1;			}			var myInterval:Number = setInterval( function():Void {				if (from > 0) {					from -= cp;					var to:Number = str.length;					tf.text = str.substring( from, to );				}				if (tf.text.length == str.length) {					clearInterval( myInterval );					if (htm == true) {						tf.htmlText = hstr;					}					tf.pushing = undefined;					cb( );				}				updateAfterEvent( );			}, ms );		}	}
	/**	 * text animation "types" text into field	 * @param tf (TextField) target text	 * @param str (String) string to animate in	 * @param cursor (String) cursor character	 * @param isFocus (Boolean) switch textfield to input type and add caret to end of string	 * @param alphaStep (Number) alpha fade increment	 * @param pi (Number) pause intervals	 * @param ms (Number) miliseconds	 * @param cb (Function) callback	 * @return Void	 */	public static function itype(tf:TextField, str:String, cursor:String, isFocus:Boolean, alphaStep:Number, pi:Number, ms:Number, cb:Function):Void {		var anim:String = "$__xtype__", fc:Number = 0, index:Number = 0, dLen:Number = str.length + 1;		if (tf[anim]) {			clearInterval( tf[anim] );		}		delete tf[anim];		tf.autoSize = true, 
		tf._alpha = 0, 
		tf.text = "", 
		tf.type = "dynamic";		tf[anim] = setInterval( function ():Void {			if (fc >= pi) {				if (tf._alpha < 100) {					tf._alpha += alphaStep;				}				if (dLen > 26) {					index += 4 + random( 3 );				} else if (dLen > 10) {					index += 2 + random( 2 );				} else {					index += 1;				}				tf.text = str.substr( 0, index ) + cursor;				dLen = (str.length + 1) - tf.length;				if (dLen < 2) {					clearInterval( tf[anim] );					delete tf[anim];					if (isFocus) {						tf.type = "input";						TextUtils.caret( tf, str.length );					}					tf.text = str;					tf._alpha = 100;					cb( );				}			} else {				fc++;			}			updateAfterEvent( );		}, ms );	}
	/**	 *  text animation "types" text out of field	 * @param tf (TextField) target text	 * @param cursor (String) cursor character	 * @param isFocus (Boolean) switch textfield to input type and add caret to end of string	 * @param ms (Number) miliseconds	 * @param cb (Function) callback	 * @return Void	 */	public static function otype(tf:TextField, cursor:String, isFocus:Boolean, ms:Number, cb:Function):Void {		var str:String = tf.text, anim:String = "$__xtype__", undex:Number = 0, toc:Number = str.length + 1;		tf.autoSize = true, 
		tf.type = "dynamic";		if (tf[anim]) {			clearInterval( tf[anim] );		}		delete tf[anim];		tf[anim] = setInterval( function ():Void {			if (toc > str.length) {				if (toc > 26) {					undex -= 4 + random( 3 );				} else if (toc > 10) {					undex -= 2 + random( 2 );				} else {					undex -= 1;				}				// old: if(toc>26) undex-=1; else if(toc>10) undex-=2+random(2); else undex-=4+random(3);				tf.text = str.substr( 0, undex ) + cursor;				toc = (str.length - 1) + tf.length;			} else {				clearInterval( tf[anim] );				delete tf[anim];				tf.text = "";				if (isFocus) {					tf.type = "input";					TextUtils.caret( tf, 0 );				}				cb( );			}			updateAfterEvent( );		}, ms );	}
	/**	 * text animation type text in, pauses and types text out of  field	 * @param tf (TextField) target text	 * @param str (String) string to animate in	 * @param cursor (String) cursor character	 * @param isFocus (Boolean) switch textfield to input type and add caret to end of string	 * @param alphaStep (Number) alpha fade increment	 * @param pi (Number) pause intervals	 * @param ms (Number) miliseconds	 * @param cb (Function) callback	 * @return Void	 */	public static function iotype(tf:TextField, str:String, cursor:String, isFocus:Boolean, alphaStep:Number, pauseIndex:Number, ms:Number, cb:Function):Void {		var anim:String = "$__iotype__", fc:Number = 0, index:Number = 0, undex:Number = 0, dLen:Number = str.length + 1, toc:Number = str.length + 1;		if (tf[anim]) {			clearInterval( tf[anim] );		}		delete tf[anim];		tf.autoSize = true, 
		tf._alpha = 0, 
		tf.text = "", 
		tf.type = "dynamic";		tf[anim] = setInterval( function ():Void {			if (tf._alpha < 100) {				tf._alpha += alphaStep;			}			if (dLen > 26) {				index += 4 + random( 3 );			} else if (dLen > 10) {				index += 2 + random( 2 );			} else {				index += 1;			}			tf.text = str.substr( 0, index ) + cursor;			dLen = (str.length + 1) - tf.length;			if (dLen < 2) {				// finished type-in				tf.text = str;				tf._alpha = 100;				if (fc >= pauseIndex) {					// if pause is finished					//--------------------------------------					if (toc > str.length) {						//--untype start--						//if(toc>26) undex -= 4+random(3); else if(toc>10) undex -= 2+random(2); else undex -= 1; // old						if (toc > 26) {							undex -= 1;						} else if (toc > 10) {							undex -= 2 + random( 2 );						} else {							undex -= 4 + random( 3 );						}						tf.text = str.substr( 0, undex ) + cursor;						toc = (str.length - 1) + tf.length;						//--untype stop--					} else {						// finished type-out: exit						clearInterval( tf[anim] );						delete tf[anim];						tf.text = "";						if (isFocus) {							tf.type = "input";							TextUtils.caret( tf, str.length );						}						cb( );					}					//--------------------------------------				} else {					fc++;				}			}			updateAfterEvent( );		}, ms );	}
	private function TextEffects() {	}}