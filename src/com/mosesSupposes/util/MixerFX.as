import com.mosesSupposes.fusefx.IFuseFX;import com.mosesSupposes.fuse.FuseKitCommon;import com.mosesSupposes.fusefx.FXProperty;import com.mosesSupposes.fusefx.FuseFX;/** * FuseFX utility * Copyright (c) 2007 Moses Gunesch, MosesSupposes.com * @ignore *  * MixerFX: tween one of this extension's registry keys directly on a Sound instance without subclassing Sound. *  * @usage * Another approach is to subclass Sound, as shown in the SoundPlus example.  * <pre>import com.mosesSupposes.fuse.*; * import com.mosesSupposes.fusefx.*; * import com.mosesSupposes.util.*; *  * ZigoEngine.register( PennerEasing ); * FuseFX.register( MixerFX ); *  * var mySound:Sound = new Sound(); * mySound.attachSound("librarySound"); * mySound.start(0, 10); *  * // Fade to half volume using the engine * ZigoEngine.doTween(mySound, MixerFX.VOLUME, 50, 2, "easeInOutQuint"); *  * // You can't use the constants with Fuse's object-literal syntax, * // so instead of MixerFX.pan you should use the value of the constant "panFX" * var f:Fuse = new Fuse({ target:mySound, panFX:100, time:2, ease:"easeInOutQuint" }); * f.start();</pre> *  * This extension provides only the most basic controls, volume and pan.  * It could be updated to include more complex Sound.setTransform controls.  *   * @author  Moses Gunesch * @version 0.3 */ class com.mosesSupposes.util.MixerFX implements IFuseFX {		/**	 * Tweens a Sound object's volume level	 */	public static var VOLUME : String = 'volumeFX';		/**	 * Tweens a Sound object's pan level	 */	public static var PAN : String = 'panFX';		// -= private =-		private var requiredVersion:Number = 0.3;		private var prop : String;		/**	 * Required by IFuseFX for compliance with FuseFX. 	 * @return	An Array of FXProperty instances.	 */	public function defineProperties() : Array {		if (FuseFX.VERSION==undefined || FuseFX.VERSION<requiredVersion) {			FuseKitCommon.output('* MixerFX did not register! FuseFX version '									+requiredVersion+' is required. *');			return null;		}		var a:Array = [];		a.push( new FXProperty(MixerFX, VOLUME, null) );		a.push( new FXProperty(MixerFX, PAN, null) );		return a;	}		/**	 * Required by IFuseFX for compliance with FuseFX. 	 * Setup, called just prior to tweening. 	 * 	 * @param target	The tween target object (not necessary to store a hard reference!)	 * @param prop		The tween property which has been pre-verified as one of this extension's keys.	 * @param endval	The tween end-value passed by the user (for special cases like type checking)	 */	public function addTween(target:Object, prop:String, endval:Object) : Boolean {				if (!(target instanceof Sound)) {			FuseKitCommon.output("* MixerFX tween failed: tween target should be a Sound instance. *"); 			return false;		}				// since there are multiple tweenable properties in this class, save the one being tweened.		this.prop = prop; 				// Important: write a new variable directly into the Sound object since this is 		// what the doTween call specifies and the engine needs a valid numerical start value for tweening.		if (prop==VOLUME) {			target[ prop ] = Sound(target).getVolume();		}		else {			target[ prop ] = Sound(target).getPan();		}				// Optional step: hides the properties from for-in loops, value is still read/write		_global.ASSetPropFlags(target, prop, 3, 1); // (3,1 is not a mistake)				return true;	}		/**	 * Required by IFuseFX for compliance with FuseFX. 	 * Standard event fired by the engine on its update pulse just after updating the property. 	 * 	 * @param o		Event object sent by engine containing {target:Object, props:Array}	 */	public function onTweenUpdate(o:Object) : Void {		var target : Sound = Sound( o.target );		if (prop==VOLUME) {			target.setVolume( target[ prop ] );		}		else {			target.setPan( target[ prop ] );		}	}		/**	 * Required by IFuseFX for compliance with FuseFX. 	 * Cleanup, called just prior to deletion. Listeners are removed by FuseFX.	 * 	 * @param target	The original tween target, which may be missing. Passed to enable extensions to 	 * 					avoid storing a hard reference to tween targets.	 */	public function destroy(target:Object) : Void {		_global.ASSetPropFlags(target, prop, 0, 2); // makes property deletable again (0,2 is not a mistake)		delete target[ prop ]; // clean the inserted property from the target	}}