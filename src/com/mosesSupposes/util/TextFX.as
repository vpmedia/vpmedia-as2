import com.mosesSupposes.fusefx.IFuseFX;import com.mosesSupposes.fuse.FuseKitCommon;import com.mosesSupposes.fusefx.FXProperty;import com.mosesSupposes.fusefx.FuseFX;/** * FuseFX utility * Copyright (c) 2007 Moses Gunesch, MosesSupposes.com * @ignore *  * TextFX: tween one of this extension's registry keys directly on a TextField  * instance to affect its current TextFormat. *  * @usage  * This extension enables interesting effects like tweening the kerning, size, and leading of dynamic text. * <pre>import com.mosesSupposes.fuse.*; * import com.mosesSupposes.fusefx.*; * import com.mosesSupposes.util.*; *  * ZigoEngine.register( PennerEasing ); * FuseFX.register( MixerFX ); *  * // place a textfield onstage with embedded fonts named my_txt *  * // Tween kerning +20 using the engine * // This is equivalent to tweening (my_txt, "textKerningFX",...) * ZigoEngine.doTween(my_txt, TextFX.KERNING, "20", 2, "easeInOutQuint"); *  * // You can't use the constants with Fuse's object-literal syntax, * // so instead of TextFX.LEADING you should use the value of the constant "textLeadingFX" * var f:Fuse = new Fuse({ target:my_txt, textLeadingFX:"-4", time:2, ease:"easeInOutQuint" }); * f.start();</pre> *  * Tweening a TextField's color can be very useful if you've applied BitmapFilters to the  * TextField, because tweening any color transform on the TextField results in the filters  * being colorized as well. TEXT_COLOR is a little bit tricky though, the value MUST  * register as a colors array in the engine so the value is handled as a hex. For this  * reason the name of the property is "textColorsArrayFX" instead of "colorX" both as a  * reminder, and because it is the string "colors" plus using an Array that forces this  * behavior in the engine. * <pre>ZigoEngine.doTween(myTextField, TextFormatTween.TEXT_COLOR, [[0x33FF00]], 1, "easeInQuad"); *  * // The same thing in Fuse would read: * myFuse.push({ target:myTextField, textColorsArrayFX:[0x33FF00], time:1, ease:"easeInQuad"}); * </pre> * Note that because doTween accepts an Array for its endVals parameter (for when multiple  * properties are being tweened in one call), you need to use two sets of brackets to  * indicate that the color value is itself a nested Array.  * <br><br> * The Fuse version also passes an Array but should only use one set of brackets because  * you're only declaring one property, which Fuse will send within an Array with any other  * properties in the action. *  * @author  Moses Gunesch * @version 0.3 */ class com.mosesSupposes.util.TextFX implements IFuseFX {		/**	 * This property requires special array usage...	 * @usage	 * To tween a hex value in Fuse Kit you need to specify a colors array.  	 * The string value of this property reflects this, and it is the string "colors" 	 * appearing in the variable name (plus using an Array as the value) that forces 	 * this behavior in the engine. See ZigoEngine and Fuse docs for colors array info.	 */	public static var TEXT_COLOR : String 		= 'textColorsArrayFX';		/**	 * Tweens a TextField's font size (TextFormat.size)	 */	public static var TEXT_SIZE : String 		= 'textSizeFX';		/**	 * Tweens a TextField's vertical spacing between lines (TextFormat.leading)	 */	public static var LEADING : String 			= 'textLeadingFX';		/**	 * Tweens a TextField's horizontal spacing between letters (TextFormat.letterSpacing)	 * @usage Requires Flash Player 8 or above. The terminology differs here from TextFormat 	 * which contains a boolean kerning property for auto-kern and uses letterSpacing for 	 * numerical kern.	 */	public static var KERNING : String 			= 'textKerningFX';		/**	 * Tweens a TextField's block indent (TextFormat.blockIndent)	 */	public static var BLOCKINDENT : String 		= 'textBlockIndentFX';		/**	 * Tweens a TextField's first-line indent (TextFormat.indent)	 */	public static var INDENT : String 			= 'textIndentFX';		/**	 * Tweens a TextField's left margin (TextFormat.leftMargin)	 */	public static var LEFTMARGIN : String 		= 'textLMarginFX';		/**	 * Tweens a TextField's right margin (TextFormat.rightMargin)	 */	public static var RIGHTMARGIN : String 		= 'textRMarginFX';			// -= private =-			private var requiredVersion:Number = 0.3;		private var _prop : String;		/**	 * Stores the linked property to affect in TextFormat	 */	private var realTFmtPropName : String;	/**	 * Required by IFuseFX for compliance with FuseFX.	 * @return	An Array of FXProperty instances.	 */	public function defineProperties() : Array {		if (FuseFX.VERSION==undefined || FuseFX.VERSION<requiredVersion) {			FuseKitCommon.output('* TextFX did not register! FuseFX version '									+requiredVersion+' is required. *');			return null;		}		var a:Array = [];		a.push( new FXProperty(TextFX, TEXT_COLOR, null) ); // null means no conflicting properties		a.push( new FXProperty(TextFX, TEXT_SIZE, null) );		a.push( new FXProperty(TextFX, LEADING, null) );		a.push( new FXProperty(TextFX, KERNING, null) );		a.push( new FXProperty(TextFX, BLOCKINDENT, null) );		a.push( new FXProperty(TextFX, INDENT, null) );		a.push( new FXProperty(TextFX, LEFTMARGIN, null) );		a.push( new FXProperty(TextFX, RIGHTMARGIN, null) );		return a;	}		/**	 * Required by IFuseFX for compliance with FuseFX. 	 * Setup, called just prior to tweening. 	 * 	 * @param target	The tween target object (not necessary to store a hard reference!)	 * @param prop		The tween property which has been pre-verified as one of this extension's keys.	 * @param endval	The tween end-value passed by the user (for special cases like type checking)	 */	public function addTween(target:Object, prop:String, endval:Object) : Boolean {				if (!(target instanceof TextField)) {			FuseKitCommon.output("* TextFX tween failed: tween target should be a TextField instance. *"); 			return false;		}				// since there are multiple tweenable properties in this class, save the one being tweened.		this._prop = prop; 				var existingTFmt : TextFormat = target.getTextFormat();				realTFmtPropName = getTextFmtProp();				// Preset the variable to be tweened to a valid numerical value inside the target,		// since the user will actually be tweening for instance 'textColorsArrayFX' in a TextField.		// The value of this variable will be transfered to the TextFormat during update,		// then the variable will be removed when the tween is removed from the engine.		if (_prop == TEXT_COLOR) {			if( !(endval instanceof Array) ) {				FuseKitCommon.output("* TextFX.TEXT_COLOR tween failed: You must pass the color value inside " +									 "an Array so the engine will tween it as a hex value. See documentation " +									 "for help. *");				return false;			}						// since colors is handled inside an array, set the initial value to an array.			target[ _prop ] = [ existingTFmt[ realTFmtPropName ] ]; 		}		else {			target[ _prop ] = existingTFmt[ realTFmtPropName ]; 		}				// Optional step: hides the properties from for-in loops, value is still read/write		_global.ASSetPropFlags(target, _prop, 3, 1); // (3,1 is not a mistake)		//		trace(_prop+"/"+ realTFmtPropName +" TextFormatTween on: "+target+" starting from: "+target[ _prop ]);		return true;	}		/**	 * Required by IFuseFX for compliance with FuseFX.	 * Standard event fired by the engine on its update pulse just after updating the property. 	 * 	 * @param o		Event object sent by engine containing {target:Object, props:Array}	 */	public function onTweenUpdate(o:Object) : Void {		var target:TextField = TextField(o.target);		var fmt:TextFormat = target.getTextFormat();		if (_prop == TEXT_COLOR) {			fmt[ realTFmtPropName ] = target[ _prop ][0]; // since colors is handled inside an array, get the first value.		}		else {			fmt[ realTFmtPropName ] = target[ _prop ];		}		target.setTextFormat( fmt );	}		/**	 * Required by IFuseFX for compliance with FuseFX.	 * Cleanup, called just prior to deletion. Listeners are removed by FuseFX.	 * 	 * @param target	The original tween target, which may be missing. Passed to enable extensions to 	 * 					avoid storing a hard reference to tween targets.	 */	public function destroy(target:Object) : Void {		_global.ASSetPropFlags(target, _prop, 0, 2); // makes property deletable again (0,2 is not a mistake)		delete target[ _prop ]; // clean the inserted property from the target	}		// -= private =-			/**	 * A lookup table linking to TextFormat properties.	 */	private function getTextFmtProp():String {		if (_prop == TEXT_COLOR) return 'color';		if (_prop == TEXT_SIZE) return 'size';		if (_prop == LEADING) return 'leading';		if (_prop == KERNING) return 'letterSpacing';		if (_prop == BLOCKINDENT) return 'blockIndent';		if (_prop == INDENT) return 'indent';		if (_prop == LEFTMARGIN) return 'leftMargin';		if (_prop == RIGHTMARGIN) return 'rightMargin';	}}