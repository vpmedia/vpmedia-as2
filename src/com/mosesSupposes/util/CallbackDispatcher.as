/* 	CallbackDispatcher 2.0	(c) Moses Gunesch 2006 www.mosessupposes.com		Use in any project you want (at your own risk of course), 	I like to hear whether my code is useful so drop me a line!		----------------------	v2.0 changes: -removed: add/removeEventListeners methods, _isCallbackBroadcaster property					-added: PREFIX property	----------------------		WHAT IT DOES	------------	This class contains just one property and one method!		It routes built-in movieclip/button/textfield callbacks like 'onRelease' to your working scope.	First, intialize a target (mc/btn/tf), then addEventListener right on the target's built-in callbacks like onRollOver.		Because you may often want to scope events back to a MovieClip (or class extending MovieClip), the new PREFIX property lets	you optionally ensure that your events won't conflict with your event scope's built-in callbacks. For instance if your scope is 	a MovieClip and you've added an 'onRollOver' listener to a target, you could set CallbackDispatcher.PREFIX = 'event_' and your	events would be fired as 'event_onRollOver', etc. (PREFIX is a class property and only needs to be set once in your program.)		Another way around this potential issue is to use mx.util.Delegate. Delegates are super-powerful in that they make it easy to route	any callbacks you wish to group to a single handler that can then perform various actions based on the target and type received. 	Using delegates you won't need PREFIX since you can define any method name you want for your handlers. (See example below.)	One important note - to remove listeners that use Delegates you should store the Delegate object and pass it back to removeEventListener.		Specifics:	Existing callbacks in the target prior to addEventListener are cached, fired alongside events, and restored on removeEventListener.				However writing a similar callback to a target after using addEventListener overwrites subscribed events and may clog memory.		(This class is basically a more accessible variation on the somewhat obscure mx UI model. Honestly if I'd figured out UIEventDispatcher & LowLevelEvents	 I probably wouldn't have written this class at the time, but CBD has merit in that it's slim, trim and really straightforward.)		MULTIPLE EVENTS	---------------	V2.0 extends addEventListener and removeEventListener to accept multiple events for any handler:	mc.addEventListener ('onRollOver,onRollOut', del1);	You may now also pass more than one target to initialize: CallbackDispatcher.initialize(mc1,mc2,mc3);		PROPERTIES	----------	CallbackDispatcher.PREFIX	-Default is a blank string. If set, events fired will start with this string. 									(addEventListener & removeEventListener will accept prefixed or plain callback names after PREFIX is set.)		METHODS	-------	CallbackDispatcher.initialize(targetObj,targetObj,etc.);	-targetObjs may be MC, TF, or Button		targetObj.addEventListener (callbackNames, handler);		-callbackNames may be string, array, or comma-delimited string.	targetObj.removeEventListener (callbackNames, handler);		EXAMPLE using a Delegate (also see example files)	--------------------------------	var del1:Object = mx.utils.Delegate.create(this, handleNavItemEvent); // store for future removeEventListener calls	for (var i:Number=0; i<5; i++) {		var mc:MovieClip = scope.attachMovie('navItem', 'item'+i, i, {id:i, _y:i*100});		CallbackDispatcher.initialize(mc);		mc.addEventListener ('onRollOver, onRollOut, onRelease', del1);	}	function handleNavItemEvent(o:Object) { // A single handler for multiple events and targets keeps things concise.		var t:MovieClip = o.target;		switch (o.type) {			case:'onRollOver':				//code + return			case:'onRollOut':				//code + return			case:'onPress':				//code + return		}	}*/import mx.events.EventDispatcher;class com.mosesSupposes.util.CallbackDispatcher{	public static var PREFIX:String = '';		public static function initialize():Void	{		if (PREFIX==null) PREFIX = '';		var all:String = '|onKeyDown|onKeyUp|onSetFocus|onKillFocus|';		var tf:String = 'onChanged|onScroller|';		var btn:String = 'onDragOut|onDragOver|onMouseDown|onMouseMove|onMouseUp|onPress|onRelease|onReleaseOutside|onRollOut|onRollOver|';		var mc:String = 'onData|onLoad|onUnload|';		var ro:Object = { // exploits scope chain to write callback functions that retain a memory of 'en' (eventName) internally			__resolve:function(en:String):Function {				var f:Function = function (cbArg):Void {					if (this['__old_'+en]!=null) this['__old_'+en](); // execute prior callback if one was cached					if (en=='onSetFocus') this.dispatchEvent({target:this, type:CallbackDispatcher.PREFIX+en, oldFocus:o});					else if (en=='onKillFocus') this.dispatchEvent({target:this, type:CallbackDispatcher.PREFIX+en, newFocus:o});					else if (en.indexOf('onKey')==0) this.dispatchEvent({target:this, type:CallbackDispatcher.PREFIX+en, code:Key.getCode(), 											ascii:Key.getAscii(), shiftKey:Key.isDown(Key.SHIFT), ctrlKey:Key.isDown(Key.CONTROL)});					else this.dispatchEvent({target:this, type:CallbackDispatcher.PREFIX+en}); // type like 'event_onRollOver', etc.				};				return f;			}		};		for (var i:String in arguments) {			var o = arguments[i];			var types:String;			if (typeof o=='movieclip') types = (all+btn+mc);			else if (o instanceof Button) types = (all+btn);			else if (o instanceof TextField) types = (all+tf);			else {				trace('** Error: CallbackDispatcher only works with MovieClip, Button, or TextField instances **');				return;			}			EventDispatcher.initialize(o);			o._addEventListener = o.addEventListener;			o._removeEventListener = o.removeEventListener;			o.addEventListener = function(events, handler) {				if (typeof events=='string') events = ((events.split(' ')).join('')).split(',');				for (var j:String in events) {					var eventName:String = events[j];					if (eventName.indexOf(PREFIX)==0) eventName = eventName.slice(PREFIX.length);					if (types.indexOf('|'+eventName+'|')==-1) {						trace('** Error: CallbackDispatcher rejecting "'+eventName+'" **');						continue;					}					if (eventName.length==0 || eventName==null) {						continue;					}					if (this[eventName]!=undefined && this['__old_'+eventName]===undefined) { // cache (once to prevent recursion issues)						this['__old_'+eventName] = this[eventName];					}					else {						this['__old_'+eventName] = null; // prevents re-adding the dispatch next time addEventListener is used.					}					if (eventName.indexOf('onKey')==0) Key.addListener(o);					this[eventName] = ro[eventName]; // dynamically generates the callback function, see above					this._addEventListener(PREFIX+eventName,handler);				}			};			o.removeEventListener = function(events, handler) {				if (PREFIX==null) PREFIX = '';				if (typeof events=='string') events = ((events.split(' ')).join('')).split(',');				for (var i:String in events) {					var eventName:String = events[i];					if (eventName.indexOf(PREFIX)==0) eventName = eventName.slice(PREFIX.length);					if (this['__old_'+eventName] instanceof Function) { // restore unless null						this[eventName] = this['__old_'+eventName];					}					else {						delete this[eventName];					}					delete this['__old_'+eventName];					if (eventName.indexOf('onKey')==0 && this.onKeyUp==undefined && this.onKeyDown==undefined) {						Key.removeListener(this);					}					this._removeEventListener(CallbackDispatcher.PREFIX+eventName, handler);				}			};		}	}}