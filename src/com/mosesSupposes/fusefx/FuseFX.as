import com.mosesSupposes.fuse.ZigoEngine;import com.mosesSupposes.fusefx.IFuseFX;import com.mosesSupposes.fuse.FuseKitCommon;import com.mosesSupposes.fusefx.FXProperty;/** * FuseFX utility * Copyright (c) 2007 Moses Gunesch, MosesSupposes.com * REQUIRES Fuse Kit 2.1.3 or higher * @ignore *  * Easily extend ZigoEngine with extension classes to add new tweenable properties * @usage * There are three general approaches to extending the ZigoEngine. The most basic is subclassing  * your tween target class, as shown in the SoundPlus example. FuseFX defines new tweenable  * property names and provides a high degree of automation. A third option when neither of  * these is practical, such as extending existing MovieClip properties like _x, is to write a  * small tweenable class that acts as a surrogate tween target as in the ScreenWrap example. * <br><br> * <b>FuseFX</b> extensions define new tweenable properties that will work with any target  * type via standard doTween calls. Management of extensions is automated — they are created by  * FuseFX and destroyed as tweens complete or when conflicting properties are tweened elsewhere. * <br><br> * To set up FuseFX, use the register method to register your extension classes. * <pre>import com.mosesSupposes.fuse.*; * import com.mosesSupposes.fusefx.FuseFX; * import com.mosesSupposes.util.*; * ZigoEngine.register(PennerEasing,Fuse); * FuseFX.register( MixerFX, TextFX ); *  * ZigoEngine.doTween(my_txt, TextFX.SIZE, "10", 2, "easeInOutQuint"); * myFuse.push({ target:mySound, volumeFX:100, time:2, ease:"easeInOutQuint" });</pre> *  * The MixerFX extension claims the string "volumeFX" as its own, so whenever that  * property is tweened the extension will be used. The class MixerFX declares a static  * constant <code>MixerFX.VOLUME = "volumeFX"</code>, and that constant can be used in * tween calls to the engine to prevent typos. However, note that when writing  * Object-literals for Fuse actions, you must use the string value of the constant,  * as in the above example. <br> * <br> * <b>How FuseFX works:</b><br> * <br> * The ZigoEngine itself is not altered by the FuseFX system. When a MixerFX user  * tweens the property "volumeFX" on a Sound object, that property is still written  * into the Sound instance and tweened, as ZigoEngine would normally do. The MixerFX * extension is simply wired to the tween's update event to add further functionality  * -- in this case, calling <i>setVolume</i> on the target object. Therefore FuseFX is  * not a <i>replacement</i> for a property tween, it's just a tidy way to decorate the  * results of the tween.<br> * <br> * When registered, each extension lays claim to certain keywords (strings) returned from  * its <i>defineProperties</i> method. All properties tweened using the Fuse Kit are  * monitored via the engine's <i>onTweenAdd </i>event. If FuseFX sees the user tween * any extension's keyword, it automates the process of generating an internal instance of  * the extension, wiring event listeners to the tween, then removing the listeners and  * deleting it when the tween completes. This way, extension classes can be quite simple:  * a setup method is called once at creation, an <i>onTweenUpdate</i> handler decorates  * tween functionality, and a destroy method is called just prior to deletion to allow  * any cleanup to be done.<br> * <br> * Detailed notes for authoring extensions can be found in {@link com.mosesSupposes.fusefx.IFuseFX}  * documentation. *  * @author  Moses Gunesch * @version 0.3 (revision1) */class com.mosesSupposes.fusefx.FuseFX {		/**	 * NOTE: KEEP VERSION NUMBERS SIMPLE: X.X	 * @ignore	 * Enables FuseFX version to be retrieved at runtime or when reviewing a decompiled swf. 	 * @usage <pre>trace(FuseFX.VERSION); // if the version is incorrect, clear your ASO cache.</pre>	 */	public static var VERSION:Number = 0.3;		/**	 * Minimum required Fuse Kit version required for this version of FuseFX	 */	private static var requiredVersion:Array = [2, 1, 3];		/**	 * Internal table for externally registered classes which are stored via their registryKey string.	 */	private static var registryKeys:Object;		/**	 * Tween tracking object	 */	private static var items : Object;		/**	 * Tween tracking count	 */	private static var numItems : Number = 0;		/**	 * Pass any number of extension classes that implement IFuseFX.	 * 	 * @usage 	 * To set up FuseFX, use the register method to register your extension classes.	 * <pre>import com.mosesSupposes.fuse.*;	 * import com.mosesSupposes.fusefx.FuseFX;	 * import com.mosesSupposes.fusefx.MixerFX;	 * ZigoEngine.register(PennerEasing,Fuse);	 * FuseFX.register( MixerFX );</pre>	 */	public static function register(classReference:Function):Void	{		var fkv:String = FuseKitCommon.VERSION.slice(FuseKitCommon.VERSION.indexOf('2'));		fkv = fkv.slice(0, fkv.indexOf(' '));		var fkva:Array = fkv.split('.');		var fkva2:Array = String(fkva[fkva.length-1]).toLowerCase().split('r'); // split off minor revisions like "r1"		if (fkva2.length>1) fkva.splice(fkva.length-1, 1, fkva2[0], fkva2[1]);		for (var j:Number=0; j<requiredVersion.length; j++) {			if (_global.isNaN(Number(fkva[j]))==true 			|| (_global.isNaN(Number(fkva[j]))==false && Number(fkva[j]) < requiredVersion[j])) {				FuseKitCommon.output('\n** FuseFX ERROR: Fuse Kit Version '+requiredVersion.join('.')+' or higher is required. (Version in this SWF is '+fkv+') **\n');				return;			}		}		if (registryKeys==undefined) {			ZigoEngine.addListener(FuseFX);			registryKeys = {};		}		for (var i:String in arguments) {			var extClass:Function = Function(arguments[i]);			var extInstance:IFuseFX = IFuseFX( new extClass() );			var keys:Array = extInstance.defineProperties();			for (var j:String in keys) {				var fxproperty:FXProperty = FXProperty(keys[j]);				if (registryKeys[ fxproperty.key ]!=undefined) {					if (FXProperty(registryKeys[ fxproperty.key ]).fxclass != extClass) {						if (ZigoEngine.OUTPUT_LEVEL>0) {							FuseKitCommon.output("** Warning: Overlapping extension key: "+ fxproperty.key +" **");						}					}				}				registryKeys[ fxproperty.key ] = fxproperty;			}		}	}		/**	 * Use to check which extension keys are registered.	 * @usage	<code>trace('Registed extension keys:\n' + FuseFX.getKeyList().join('\n\t'));</code>	 * @return	An alphabetized array list of successfully registered extension keys	 */	public static function getKeyList():Array {		var a:Array = [];		for (var key:String in registryKeys) a.push(key);		a.sort();		return a;	}			// —≈ private ≈—		/**	 * Event dispatched by ZigoEngine	 * @param targets	An array of tween targets	 * @param props		An array of property strings generated by the <code>ZManager.paramsObj</code> method.	 * 					<br>Note: _scale and _size are split into movieclip properties and duplicate properties 	 * 					are stripped, with the exception of overlapping _fade / _alpha and overlapping color-transform tweens.	 * @param endvals	A corresponding array of tween end-values for each validated property	 * 	 * @exclude	 * @param seconds	A validated numerical tween duration in seconds	 * @param ease		A valid easing function	 * @param delay		A validated numerical delay in seconds	 * @param callback	A specially-formatted and validated callback object generated by the <code>FuseKitCommon.parseCallback</code> method.	 */	private static function onTweenAdd(targets:Array, props:Array, endvals:Array /*, seconds:Number, ease:Function, delay:Number, callback:Object*/):Void {		for (var i:String in props) {			var prop : String = String( props[i] );			if (prop=='__tweenedDelay') {				continue; // fuse internal delay tween, doesn't need tracking here			}			for (var key:String in registryKeys) {				if (key==prop || FXProperty(registryKeys[key]).conflictLookup[prop]==true) { // if key==prop, add a new item. If any prop being added in ZE conflicts with an extension prop, remove items.					for (var j:String in targets) {						if (key!=prop) { // possible conflict..							var zID : String = String(targets[j].__zigoID__);							if (items[zID][key]!=undefined) { // a conflicting prop was active for that target; kill the item								removeItem(targets[j], zID, key, true);							}						}						else { // Property was recognized as an extension key							addItem(targets[j], prop, endvals[i]);						}					}				}			}		}	}		/**	 * Event dispatched by ZigoEngine	 */	private static function onTweenInterrupt(o:Object) : Void {		if (items[ String(o.__zigoID__) ]!=null) {			onTweenEnd(o);		}	}		/**	 * Event dispatched by ZigoEngine (also called locally by onTweenInterrupt handler)	 */	private static function onTweenEnd(o:Object) : Void {		var zID : String = (o.target.__zigoID__!=null) ? String(o.target.__zigoID__) : String(o.__zigoID__);		var props : Array = o.props;		for (var i:String in props) {			if (items[ zID ][ props[i] ] != null) {				removeItem(o.target, zID, props[i]);			}		}	}		/**	 * Generate an extension instance, wire listeners and insert it into the items list	 * @param target	tween target	 * @param prop		tween property	 * @param endval	tween endval	 */	private static function addItem(target : Object, prop : String, endval : Object) : Void {		// create extension first, to validate		var fxproperty:FXProperty = FXProperty(registryKeys[ prop ]);		var extInstance:IFuseFX = IFuseFX( new fxproperty.fxclass() );				/* Safety: Clear the property from tweening, so the extension can set it.		 * 		 * (The way this is written resolves a tricky issue where too many rapidfire 		 * remove calls kill the engine if there's only one tween running in the SWF.) 		 */		_global.com.mosesSupposes.fuse.ZigoEngine.instance.removeTween(target, prop, true);						// Do addTween call and monitor for rejection		if ( extInstance.addTween(target, prop, endval) !== true ) {			return;		}				// Extension is valid: Add to items list		if (target.__zigoID__==null) {			// The onTweenAdd event is fired before targets are initialized.			ZigoEngine.initializeTargets(target);		}		var zID:String = String(target.__zigoID__);		if (items[ zID ][ prop ] != null) { 			// leave above other conditions -- removeItem may strip out internal objects			removeItem(target, zID, prop, true);		}		if (numItems<=0) {			items = new Object();			numItems = 0;		}		numItems++;		if (items[ zID ] == null) {			items[ zID ] = { numProps : 0 };			target.addListener( FuseFX );		}		items[ zID ][ prop ] = extInstance;		(items[ zID ]).numProps ++;		target.addListener( extInstance );				// kill conflicting properties in the target		fxproperty.removeConflicts(target);	}		/**	 * Remove an extension instance from the items list	 */	private static function removeItem(target:Object, zID:String, prop:String, isAdd:Boolean) : Void {		var extInstance : IFuseFX = IFuseFX( items[ zID ][ prop ] );		if (target!=null) {			target.removeListener( extInstance );			// call a final update, in case engine only set the property and did not tween it			extInstance.onTweenUpdate({target:target, props:[prop]});			if (isAdd==true) {				/* Resolves a very tricky issue with Fuse advance-trigger where a conflicting				 * property overwriting a previously running property, which must be viewed by 				 * the FuseItem as onTweenInterrupt:{during:'add'} so it knows it has interrupted 				 * itself and can ignore auto-stop behavior if set. FuseFX is essentially acting				 * as the engine here, so the private ZManager instance is directly accessed 				 * (mainly to avoid publishing another kit update, this might be cleaned up in 				 * future versions). The 3rd param forces 'add' in the interruption event.				 */				_global.com.mosesSupposes.fuse.ZigoEngine.instance.removeTween(target, prop, true);			}		}		extInstance.destroy(target);		delete extInstance;		delete (items[ zID ][ prop ]);		// Check for completion tracking tweens on this target		if (--(items[ zID ]).numProps <= 0) {			if (target!=null) {				target.removeListener( FuseFX );			}			delete (items[ zID ]);			if (--numItems<=0) {				delete items;				numItems = 0;			}		}	}}