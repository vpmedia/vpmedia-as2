/*==================================Class:	FuseXML ExtensionVersion:2.3.0Date:	6/24/06Author:	Andrew Fitzgerald | http://www.visualcondition.com/Uses:	Used to convert XML data into Fuse/Zigo tweens.Usage:	var FuseXMLinstance:FuseXML = new FuseXML(xmlfile:String, astart:Boolean, target:MovieClip);==================================2.3.0-Added _bezier_ support-Added multipram and multival suport-Updated XML example to show combination of possibilities2.2.0:-<Event> tags-.scope for a Fuse-triggers-Auto ZE.registers-Allows multiple targets from XML as "targ1,targ2,targ3"-Support for all callbacks-Added support for cycles, skiplevel, and func (as well as upd and start)-Added extra1 and extra2 for tweens-Fixed duplications2.1.0:-Changed class from static to regular-Added start()-New attribute of id-Added new properties-Added ability to call single ids-Many other improvments2.0.0:-Added real Fuse sequencing-Added groups-Changed multitraces to newlines-Changed ZE.OUTPUT_LEVEL to FuseXML.OUTPUT_LEVEL-Added default seconds, ease, and delay-Updated docs for Fuse support1.2.0:-Fixed target overide-Added any target-Updated traces-Updated comments================================== Example:_______________________XML File Contents(test.xml):<FuseXML>	<Fuse id="home">		<Tween targ="rj" param="_alpha" val="*-20" seconds="2"/>		<Event name="onRunnerBorn"/>		<Group>			<Tween targ="popo" param="_x,_alpha" val="*20,0" seconds="2" cycles="6"/>			<Tween targ="rj" param="_x" val="*50" seconds="2" ease="easeOutQuint" delay="0" func="rap"/>			<Tween id='cat' val="*10" targ="rj" param="_scale" ease="easeOutQuint" delay="2" seconds="1" easyfunc="trace('happy');"/>			<Event name="onRunnerDied"/>		</Group>		<Tween targ="popo" param="_alpha" val="*-20" seconds="2"/>		<Tween targ="rj" param="_alpha" val="30" seconds="2"/>	</Fuse>	<Tween targ="rj,popo" param="_bezier_" val="0,50,*100,null" seconds="3" ease="easeOutBounce"/></FuseXML>AS:import com.mosesSupposes.fuse.*;ZigoEngine.register(PennerEasing, Fuse);FuseXML.OUTPUT_LEVEL = 2;//Fuse.OUTPUT_LEVEL = 2;var fun:FuseXML = new FuseXML('test.xml');fun.start();_root.onMouseDown = function() {fun.start('tween1');};_____________________Notes:If no id is specified, it will auto increase id.Tween: tween1, tween2, cat, tween3Fuse: fuse1, home, fuse2, tween3You can run a single tween by id, or a Fuse sequnce by id:fun.start('tween1');fun.start('home');If a .target is specified, it will use that instead unless over-ridded.<Fuse> and <Tween> are required exactly, case-sensitive, at those levels.You can also have other data in the XML file and in-between tags.The order of attributes does NOT matter.Callback attributes are the same names as they are in Fuse.You can use FuseXMLinstance.target to overide all targets for a single target.Setting FuseXML.OUTPUT_LEVEL = 2 will show more information. 0 will show none. 1 is default.If param is _bezier_ you can only use that one. No multiparam/vals.For the "val=" in the XML data, use an "*" to represent relative value.    Ex: <Tween targ="rj" param="_y" val="*-100" seconds="3" ease="easeOutSine" delay="0"></Tween>*/import com.mosesSupposes.fuse.*;class com.mosesSupposes.fuse.FuseXML extends Object {	private static var FVERSION:String = "2.0";	private static var FAUTHOR:String = 'Andrew Fitzgerald';	public static var default_seconds:Number = 1;	public static var default_ease:String = 'easeOutQuint';	public static var default_delay:Number = 0;	public static var OUTPUT_LEVEL:Number = 1;	public var xmlfile:String;	public var fuses:Object;	public var tweens:Object;	public var target:MovieClip;	/**	* @class FuseXML	* @tooltip Creates a FuseXML object.	* @param xmlfile (String) The fle to parse.	* @param astart (Boolean) To auto start.	* @param target (MovieClip) Target for all tweens.	* @return Nothing.	*/	function FuseXML(xmlfile:String, astart:Boolean, target) {		_global.FuseXML = com.mosesSupposes.fuse.FuseXML;		ZigoEngine.register(PennerEasing);		if (xmlfile == undefined) {			if (FuseXML.OUTPUT_LEVEL >= 1) {				trace("FuseXML: XML file required.");			}			return;		} else {			this.xmlfile = xmlfile;		}		this.fuses = new Object();		this.tweens = new Object();		this.tweens.length = 0;		this.fuses.length = 0;		this.target = target;		var astart = (astart == undefined) ? false : astart;		//trace("FuseXML " + VERSION + " by " + AUTHOR);		assemble(xmlfile, astart, target, true);	}	/**	* @method start	* @tooltip Starts the entire FuseXML item or an id.	* @param id (String) The tween or Fuse to run. undefined to run all.	* @param usetarg (Boolean) To use instance.target instead.	* @return (Boolean) If started.	*/	public function start(id:String, usetarg:Boolean):Boolean {		var usetarg = (usetarg == undefined) ? true : usetarg;		if (id == undefined) {			if (FuseXML.OUTPUT_LEVEL >= 1) {				trace("FuseXML: Entire FuseXML sequence started.");			}			var utg = (usetarg) ? this.target : undefined;			assemble(this.xmlfile, true, utg);			return true;		} else {			for (var i in this.tweens) {				if (this.tweens[i] == this.tweens[id]) {					var tar:Array = this.tweens[i];					if (usetarg) {						tar[0] = (this.target == undefined) ? tar[0] : this.target;					}					ZigoEngine.doTween.apply(null, tar);					if (FuseXML.OUTPUT_LEVEL >= 1) {						trace("FuseXML: Tween started.");					}					return true;				}			}			for (var i in this.fuses) {				if (this.fuses[i] == this.fuses[id]) {					var runfuse = this.fuses[i];					if (usetarg) {						runfuse.target = (this.target == undefined) ? runfuse.target : this.target;					}					runfuse.start();					if (FuseXML.OUTPUT_LEVEL >= 1) {						trace("FuseXML: Fuse sequence started.");					}					return true;				}			}			if (FuseXML.OUTPUT_LEVEL >= 1) {				trace("FuseXML: Error starting. Reason: ID not found.");			}			return false;		}	}	public function get VERSION():String {		return FVERSION;	}	public function get AUTHOR():String {		return FAUTHOR;	}	private function assemble(xmlfile:String, astart:Boolean, targovrd, firsttime:Boolean):Void {		if (xmlfile == undefined) {			break;		}		var tt = this;		var zigoxml = new XML();		zigoxml.ignoreWhite = true;		zigoxml.load(xmlfile);		zigoxml.onLoad = function(success) {			var main:XMLNode = this.firstChild;			var totalnodes:Number = main.childNodes.length;			var i;			var qt:Number = 0;			for (i = 0; i < totalnodes; i++) {				switch (main.childNodes[i].nodeName) {				case "Fuse" :					if (firsttime) {						ZigoEngine.register(Fuse);					}					var totaltweens:Number = main.childNodes[i].childNodes.length;					var tweennode:XMLNode = main.childNodes[i].childNodes;					var fid:String = main.childNodes[i].attributes.id;					if (firsttime) {						if (fid != undefined) {							var fxml = tt.fuses[fid] = new Fuse();						} else {							var fxml = tt.fuses['fuse' + ++tt.fuses.length] = new Fuse();						}						var fscope = eval(main.childNodes[i].attributes.scope);						if (fscope != undefined) {							fxml.scope = fscope;						}					} else {						///						if (fid != undefined) {							var fxml = tt.fuses[fid];						} else {							var fxml = tt.fuses['fuse' + ++qt];						}					}					break;				case "Tween" :					var totaltweens:Number = 1;					var tweennode:Array = [main.childNodes[i]];					break;				}				var k;				for (k = 0; k < totaltweens; k++) {					var td = tweennode[k].attributes;					switch (tweennode[k].nodeName) {					case "Event" :						if (firsttime) {							fxml.push({event:td.name});							if (FuseXML.OUTPUT_LEVEL >= 2) {								trace("FuseXML: Added " + td.name + " to Fuse sequence.");							}						}						break;					case "Tween" :						var targ = [];						var targar:Array = td.targ.split(",");						for (var t = 0; t < targar.length; t++) {							targ.push(eval(targar[t]));						}						if (targ[1] == undefined) {							targ = eval(td.targ);						}						if (targovrd != undefined) {							var targ = targovrd;							if (FuseXML.OUTPUT_LEVEL >= 1) {								trace("FuseXML: Using one single target overide.");							}						}						var param:Array = [td.param];						var val = [];						var valar:Array = td.val.split(",");						for (var o = 0; o < valar.length; o++) {							if (valar[o].charCodeAt(0) == 42) {								val.push(valar[o].slice(1));							} else if (valar[o] == 'null') {								val.push(null);							} else {								val.push(Number(valar[o]));							}						}						if (td.param == "_bezier_") {							val = {x:val[0], y:val[1], controlX:val[2], controlY:val[3]};						}						var cbobj:Object = {};						//callbacks						if (td.args != undefined) {							cbobj.args = td.args.split(",");						}						if (td.scope != undefined) {							cbobj.scope = eval(td.scope);						}						if (td.func != undefined) {							cbobj.func = td.func;						}						//start                                        						if (td.startargs != undefined) {							cbobj.startargs = td.startargs.split(",");						}						if (td.startscope != undefined) {							cbobj.startscope = eval(td.startscope);						}						if (td.startfunc != undefined) {							cbobj.startfunc = td.startfunc;						}						///                                        						if (td.updargs != undefined) {							cbobj.updargs = td.updargs.split(",");						}						if (td.updscope != undefined) {							cbobj.updscope = eval(td.updscope);						}						if (td.updfunc != undefined) {							cbobj.updfunc = td.updfunc;						}						if (td.cycles != undefined) {							cbobj.cycles = Number(td.cycles);						}						if (td.skipLevel != undefined) {							cbobj.skipLevel = Number(td.skipLevel);						}						if (td.easyfunc != undefined) {							ZigoEngine.register(Shortcuts);							cbobj.easyfunc = td.easyfunc;						}						//////////////                                        						var seconds:Number = (td.seconds == undefined) ? FuseXML.default_seconds : Number(td.seconds);						var ease:String = (td.ease == undefined) ? FuseXML.default_ease : td.ease;						var delay:Number = (td.delay == undefined) ? FuseXML.default_delay : Number(td.delay);						if (firsttime) {							if (FuseXML.OUTPUT_LEVEL >= 2) {								trace("FuseXML: Single Tween" + newline + "FuseXML: Target: " + targ + newline + "FuseXML: Param: " + param + newline + "FuseXML: Value: " + val + newline + "FuseXML: Seconds: " + seconds + newline + "FuseXML: Ease: " + ease + newline + "FuseXML: Delay: " + delay + newline);							}						}						switch (main.childNodes[i].nodeName) {						case "Fuse" :							if (firsttime) {								fxml.pushTween(targ, param, val, seconds, ease, delay, cbobj, td.extra1, td.extra2);							}							break;						case "Tween" :							if (astart) {								ZigoEngine.doTween(targ, param, val, seconds, ease, delay, cbobj, td.extra1, td.extra2);							}							break;						}						if (firsttime) {							var tid = td.id;							if (tid != undefined) {								tt.tweens[tid] = [targ, param, val, seconds, ease, delay, cbobj, td.extra1, td.extra2];							} else {								tt.tweens['tween' + ++tt.tweens.length] = [targ, param, val, seconds, ease, delay, cbobj, td.extra1, td.extra2];							}						}						break;						///////////					case "Group" :						var totaltweensg:Number = tweennode[k].childNodes.length;						if (firsttime) {							if (FuseXML.OUTPUT_LEVEL >= 2) {								trace("FuseXML: Fuse Group");							}						}						if (firsttime) {							var group = [];						}						var tweennodeg:XMLNode = tweennode[k].childNodes;						var l;						for (l = 0; l < totaltweensg; l++) {							var tdg = tweennodeg[l].attributes;							switch (tweennodeg[l].nodeName) {							case "Event" :								if (firsttime) {									fxml.push({event:tdg.name});									if (FuseXML.OUTPUT_LEVEL >= 2) {										trace("FuseXML: Added " + tdg.name + " to Fuse sequence.");									}								}								break;							case "Tween" :								if (firsttime) {									var targ = [];									var targar:Array = tdg.targ.split(",");									for (var t = 0; t < targar.length; t++) {										targ.push(eval(targar[t]));									}									if (targ[1] == undefined) {										targ = eval(tdg.targ);									}									if (targovrd != undefined) {										var targ = targovrd;										if (FuseXML.OUTPUT_LEVEL >= 1) {											trace("FuseXML: Using one single target overide.");										}									}									var param:Array = [tdg.param];									var val = [];									var valar:Array = tdg.val.split(",");									for (var y = 0; y < valar.length; y++) {										if (valar[y].charCodeAt(0) == 42) {											val.push(valar[y].slice(1));										} else if (valar[y] == 'null') {											val.push(null);										} else {											val.push(Number(valar[y]));										}									}									if (tdg.param == "_bezier_") {										val = {x:val[0], y:val[1], controlX:val[2], controlY:val[3]};									}									var cbobj:Object = {};									//callbacks									if (tdg.args != undefined) {										cbobj.args = tdg.args.split(",");									}									if (tdg.scope != undefined) {										cbobj.scope = eval(tdg.scope);									}									if (tdg.func != undefined) {										cbobj.func = tdg.func;									}									//start                                       									if (tdg.startargs != undefined) {										cbobj.startargs = tdg.startargs.split(",");									}									if (tdg.startscope != undefined) {										cbobj.startscope = eval(tdg.startscope);									}									if (tdg.startfunc != undefined) {										cbobj.startfunc = tdg.startfunc;									}									///                                       									if (tdg.updargs != undefined) {										cbobj.updargs = tdg.updargs.split(",");									}									if (tdg.updscope != undefined) {										cbobj.updscope = eval(tdg.updscope);									}									if (tdg.updfunc != undefined) {										cbobj.updfunc = tdg.updfunc;									}									if (tdg.cycles != undefined) {										cbobj.cycles = Number(tdg.cycles);									}									if (tdg.skipLevel != undefined) {										cbobj.skipLevel = Number(tdg.skipLevel);									}									if (tdg.easyfunc != undefined) {										ZigoEngine.register(Shortcuts);										cbobj.easyfunc = tdg.easyfunc;									}									//////////////                                       									var seconds:Number = (tdg.seconds == undefined) ? FuseXML.default_seconds : Number(tdg.seconds);									var ease:String = (tdg.ease == undefined) ? FuseXML.default_ease : tdg.ease;									var delay:Number = (tdg.delay == undefined) ? FuseXML.default_delay : Number(tdg.delay);									if (firsttime) {										if (FuseXML.OUTPUT_LEVEL >= 2) {											trace("FuseXML: Target: " + targ + newline + "FuseXML: Param: " + param + newline + "FuseXML: Value: " + val + newline + "FuseXML: Seconds: " + seconds + newline + "FuseXML: Ease: " + ease + newline + "FuseXML: Delay: " + delay);										}									}									group.push({__buildMode:true, tweenargs:[targ, param, val, seconds, ease, delay, cbobj, tdg.extra1, tdg.extra2]});									if (tdg.trigger != undefined) {										group[group.length - 1]._bTrigger = Boolean(tdg.trigger);									}									if (group[group.length - 1]._bTrigger == undefined) {										group[group.length - 1]._bTrigger = false;									}									trace(group[group.length - 1]._bTrigger);									var tid = tdg.id;									if (tid != undefined) {										tt.tweens[tid] = [targ, param, val, seconds, ease, delay, cbobj, tdg.extra1, tdg.extra2];									} else {										tt.tweens['tween' + ++tt.tweens.length] = [targ, param, val, seconds, ease, delay, cbobj, tdg.extra1, tdg.extra2];									}									break;								}							}						}						if (firsttime) {							if (FuseXML.OUTPUT_LEVEL >= 2) {								trace("");							}							fxml.push(group);						}						break;					}				}				if (main.childNodes[i].nodeName = "Fuse") {					if (astart) {						fxml.start();					}				}			}		};	}}