/*Class	ScrollHandButtonPackage	ch.component.scrollbarProject	MainAPICreated by :	Tabin Cedric - thecaptainCreated at :	4 august 2006*///importimport ch.component.scrollbar.ScrollBar;import ch.component.scrollbar.ScrollType;import ch.component.scrollbar.ScrollBarModel;import ch.component.scrollbar.ScrollManager;import ch.component.scrollbar.ScrollBarManager;import ch.component.scrollbar.AbstractScrollBarManager;import ch.util.Delegate;import ch.component.scrollbar.ScrollListener;import ch.component.scrollbar.ScrollEvent;/** * Manage the drag of a content. * <p>This class allows you to set the content of a {@code ScrollBar} being dragged in * the predefined positions (margins included). You have many ways to implement the dragging * of the content with this class.<br><code> * var verticalSB:ScrollBar = ScrollBar.create(this.clipContent, this.clipMask, ScrollType.VERTICAL);<br> * var horizontalSB:ScrollBar = ScrollBar.create(this.clipContent, this.clipMask, ScrollType.HORIZONTAL);<br> * <br> * //create the scrollers, etc.<br> * <br> * var shb:ScrollHandButton = ScrollHandButton.createAsContentPane(this.clipContent, horizontalSB.getModel(), verticalSB.getModel());<br> * </code></p> * <p>You can use the MVC pattern to adjust the actions of your {@code ScrollHandButton} :<br> * <code> * var verticalSB:ScrollBar = ScrollBar.create(this.clipContent, this.clipMask, ScrollType.VERTICAL);<br> * var horizontalSB:ScrollBar = ScrollBar.create(this.clipContent, this.clipMask, ScrollType.HORIZONTAL);<br> * <br> * var shb:ScrollHandButton = new ScrollHandButton(this.clipContent);<br> * shb.setHorizontalScrollManager(horizontalSB.getModel().getScrollManager()); //used to have the left/right coordinates<br> * shb.setVerticalScrollManager(verticalSB.getModel().getScrollManager()); //used to have the top/bottom coordinates<br> * <br> * //the event is dispatched to both models<br> * shb.addScrollBarModel(horizontalSB.getModel());<br> * shb.addScrollBarModel(verticalSB.getModel());<br> * </code></p> * <p>Note that a {@code ScrollHandButton} allows you to use only 2 types of {@code ScrollType} : Horizontal and Vertical. Thoses * properties are used to define the rectangle where the content can be dragged.</p> *  * @see			ch.component.scrollbar.ScrollBar#getHandButton() * @author		Tabin Cedric - thecaptain * @since		4 août 2006 * @version		1.8.1 */class ch.component.scrollbar.ScrollHandButton extends AbstractScrollBarManager implements ScrollBarManager, ScrollListener{	//---------//	//Constants//	//---------//		//---------//	//Variables//	//---------//	private var _content:MovieClip;	private var _scrollH:ScrollManager;	private var _scrollV:ScrollManager;	private var _oldMouseMove:Function;		/**	 * Defines if a refresh event must be dispatched even when the mouse	 * is pressed or only when the mouse is released.	 */	public var alwaysRefresh:Boolean;		//-----------------//	//Getters & Setters//	//-----------------//			//-----------//	//Constructor//	//-----------//		/**	 * Create a new ScrollHandButton.	 * 	 * @param	content			The {@code MovieClip} to be dragged.	 * @param	alwaysRefresh	Defines if the refresh event sould be dispatched when the	 * 							mouse is pressed.	 * @throws	Error			If {@code content} is {@code null}.	 */	public function ScrollHandButton(content:MovieClip, alwaysRefresh:Boolean)	{		if (content == null) throw new Error(this+".<init> : content is not defined");				if (alwaysRefresh == null) alwaysRefresh = true;		this.alwaysRefresh = alwaysRefresh;				_content = content;		_scrollH = null;		_scrollV = null;		_oldMouseMove = null;				_content.onPress = Delegate.getRedirect(this, "onContentPress");		_content.onRelease = Delegate.getRedirect(this, "onContentRelease");		_content.onReleaseOutside = Delegate.getRedirect(this, "onContentReleaseOutside");	}		//--------------//	//Public methods//	//--------------//		/**	 * Create a new {@code ScrollHandButton} as a content pane.	 * <p>Within this method, it will create a {@code ScrollHandButton} managed	 * by a vertical scrollbar and an horizontal scrollbar. It can be useful if	 * you uste it for map dragging for example.</p>	 * 	 * @param		content		The target clip to drag.	 * @param		hModel		The {@code ScrollBarModel} of the horizontal scrollbar.	 * @param		vModel		The {@code ScrollBarModel} of the vertical scrollbar.	 * @return		The {@code ScrollHandButton} created.	 */	public static function createAsContentPane(content:MovieClip, hModel:ScrollBarModel, vModel:ScrollBarModel):ScrollHandButton	{		var shb:ScrollHandButton = new ScrollHandButton(content);		shb.setVerticalScrollManager(vModel.getScrollManager());		shb.setHorizontalScrollManager(hModel.getScrollManager());				if (hModel != null)		{			shb.addScrollBarModel(hModel);			hModel.addListener(shb);		}				if (vModel != null)		{			shb.addScrollBarModel(vModel);			vModel.addListener(shb);		}				return shb;	}		/**	 * Get the content to be scrolled.	 * 	 * @return	The content.	 */	public function getContent(Void):MovieClip	{		return _content;	}		/**	 * Enable or disable the content.	 * 	 * @param	value	{@code true} to enable the content, {@code false} otherwise.	 */	public function setEnabled(value:Boolean):Void	{		super.setEnabled(value);		_content.enabled = value;	}		/**	 * Method called when a scroll is performed on a	 * {@code ScrollBarModel}.	 * 	 * @param	event	The event object.	 */	public function scrollPerformed(event:ScrollEvent):Void	{		//retrieves the model		var model:ScrollBarModel = ScrollBarModel(event.getSource());		var src:Boolean = model.isScrollable();				if (model.getType() == ScrollType.HORIZONTAL)		{			if (_scrollV == null ||									//vertical scroll not defined			   (_scrollV.getMinMove() > _scrollV.getMaxMove()))     //vertical scroll not possible				setEnabled(src);		}		else		{			if (_scrollH == null ||									//horizontal scroll not defined			   (_scrollH.getMinMove() > _scrollH.getMaxMove()))     //horizontal scroll not possible				setEnabled(src);		}	}		/**	 * Set the vertical scroll manager.	 * <p>The vertical {@code ScrollManager} is used to retrieve the top/bottom coordinates	 * of the content to be dragged.</p>	 * 	 * @param	vScrollManager		The vertical {@code ScrollManager} or {@code null}.	 * @throws	Error				If {@code vScrollManager} is not {@link ch.component.scrollbar.ScrollType#VERTICAL}.	 */	public function setVerticalScrollManager(vScrollManager:ScrollManager):Void	{		//release the scroll manager		if (vScrollManager == null)		{			_scrollV = null;			return;		}				if (vScrollManager.getType() != ScrollType.VERTICAL) throw new Error(this+".setVerticalScrollManager : vScrollManager is invalid");				_scrollV = vScrollManager;	}		/**	 * Set the horizontal scroll manager.	 * <p>The horizontal {@code ScrollManager} is used to retrieve the left/right coordinates	 * of the content to be dragged.</p>	 * 	 * @param	hScrollManager		The horizontal {@code ScrollManager} or {@code null}.	 * @throws	Error				If {@code hScrollManager} is not {@link ch.component.scrollbar.ScrollType#HORIZONTAL}.	 */	public function setHorizontalScrollManager(hScrollManager:ScrollManager):Void	{		//release the scroll manager		if (hScrollManager == null)		{			_scrollH = null;			return;		}				if (hScrollManager.getType() != ScrollType.HORIZONTAL) throw new Error(this+".setHorizontalScrollManager : hScrollManager is invalid");				_scrollH = hScrollManager;	}		/**	 * Get the vertical scroll manager.	 * 	 * @return	The vertical {@code ScrollManager}.	 */	public function getVerticalScrollManager(Void):ScrollManager	{		return _scrollV;	}		/**	 * Get the horizontal scroll manager.	 * 	 * @return	The horizontal {@code ScrollManager}.	 */	public function getHorizontalScrollManager(Void):ScrollManager	{		return _scrollH;	}		/**	 * Method called when the content is pressed.	 */	public function onContentPress(Void):Void	{		//nothing to do		if (_scrollV == null && _scrollH == null) return;				var l:Number = _content._x;		var t:Number = _content._y;		var r:Number = _content._x;		var b:Number = _content._y;				if (_scrollV != null)		{			t = _scrollV.getMinMove();			b = _scrollV.getMaxMove();						if (t > b) t = b;		}				if (_scrollH != null)		{			l = _scrollH.getMinMove();			r = _scrollH.getMaxMove();						if (l > r) l = r;		}				var me:ScrollHandButton = this;		_oldMouseMove = _content.onMouseMove; //save the old mouse move		_content.startDrag(false, l, t, r, b);		_content.onMouseMove = function(Void):Void		{			//refresh			if (me.alwaysRefresh) me.refresh();						//call the old mouse move function			if (me._oldMouseMove != null) me._oldMouseMove();		};	}		/**	 * Method called when the content is released.	 */	public function onContentRelease(Void):Void	{		_content.stopDrag();				if (_oldMouseMove != null) _content.onMouseMove = _oldMouseMove;		else delete _content.onMouseMove;				//refresh the models		refresh();	}		/**	 * Method called when the content is released outside.	 * <p>This method simply call the {@code onContentRelease} method.</p>	 */	public function onContentReleaseOutside(Void):Void	{		onContentRelease();	}		/**	 * Represent the current instance into a String.	 *	 * @return	A String representing the ScrollHandButton instance.	 */	public function toString(Void):String	{		return "ch.component.scrollbar.ScrollHandButton";	}		//---------------//	//Private methods//	//---------------//	}