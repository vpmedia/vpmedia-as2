import ch.sfug.events.Event;/** * main class for dispatching events. if you want to dispatch events in your own classes extend this class.<br> * you can register/listen to an event as the following example shows: * <br> * <pre> * dispatcher = new EventDispatcher(); * dispatcher.addEventListener( Event.COMPLETE, catchEvent, this ); // the function this.catchEvent will be called if the Event.COMPLETE event is called * * dispatcher.dispatchEvent( new Event( Event.COMPLETE ) ); // will fire the function * </pre> * * @author mich */class ch.sfug.events.EventDispatcher {	private var listener:Object;	private var isdispatch:Boolean = true;	/**	 * initalize the EventDispatcher	 */	public function EventDispatcher() {		listener = new Object();	}	/**	 * will dispatch an event	 * @param e the event to dispatch	 */	public function dispatchEvent( e:Event ):Void {		if( isdispatch ) {			e.target = this;			var all:Array = listener[ e.type ];			var l:Number = all.length;			while( --l > -1 ) {				var o:Object = all[l];				o.f.apply( o.o, [ e ] );			}		}	}	/**	 * adds an eventlistener to the dispatcher	 * @param type the type of event you want to listen to. for example Event.COMPLETE	 * @param func the function will be called when the event occurs	 * @param obj the object on which the function will be called. normally this	 */	public function addEventListener( type:String, func:Function, obj:Object ):Void {		if( listener[ type ] == undefined ) listener[ type ] = new Array();		if( findListener( type, func, obj ) == -1 ) {			listener[ type ].push( { f:func, o:obj } );		} else {			trace( "the eventlistener is already added: " + type + " on " + obj );		}	}	/**	 * removes an event listener from the event dispatcher	 * @param type the type of event you have to listen to. for example Event.COMPLETE	 * @param func the function were called when the event occurs	 * @param obj the object on which the function will be called.	 */	public function removeEventListener( type:String, func:Function, obj:Object ):Void {		if( type != undefined && func != undefined && obj != undefined ) {			var i:Number = findListener( type, func, obj );			if( i > -1 ) {				listener[ type ].splice( i, 1 );			} else {				trace( "cant find listener to remove with type: " + type + " on object: " + obj + "with func: " + func );			}		} else {			trace( "you have to specify all parameters: type: " + type + ", func: " + func + ", obj: " + obj );		}	}	/**	 * returns true if the dispatcher has a listener on the given type	 * @param type the type to look for a listener	 */	public function hasEventListener( type:String ):Boolean {		return listener[ type ].length > 0;	}	/**	 * returns the index of the function and object pair	 */	private function findListener( type:String, func:Function, obj:Object ):Number {		var o:Array = listener[ type ];		var l:Number = o.length;		while( ( o[--l].o != obj || o[l].f != func ) && l > -1 );		return l;	}	/**	 * sets the enabled property to true/false	 */	public function set enabled( state:Boolean ):Void {		isdispatch = state;	}	/**	 * gets the enabled property	 */	public function get enabled( ):Boolean {		return isdispatch;	}}